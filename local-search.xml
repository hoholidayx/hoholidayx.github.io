<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>小记HashMap相关</title>
    <link href="/2020/04/26/%E5%B0%8F%E8%AE%B0HashMap%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/04/26/%E5%B0%8F%E8%AE%B0HashMap%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>代码版本：<a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:libcore/ojluni/src/main/java/java/util/HashMap.java" target="_blank" rel="noopener">java/util/HashMap.java @ Android-10.0.0_r30</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap 是 Android、Java 面试的常客，阅读学习其源码还是很有必要的。总之先来一个 HashMap 的整体结构，然后顺着慢慢分析。</p><p><img src="HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" srcset="/img/loading.gif" alt="HashMap存储结构.jpg"></p><p>HashMap 的存储结构由数组、链表和红黑树组成，JDK1.8 之前没有使用红黑树。</p><h1 id="构造-HashMap"><a href="#构造-HashMap" class="headerlink" title="构造 HashMap"></a>构造 HashMap</h1><p>HashMap 的构建有两个重要的参数：</p><ul><li>initialCapacity，初始容量</li><li>loadFactor，负载因子，和扩容有关，默认值 0.75</li></ul><pre><code class="java"> public HashMap(int initialCapacity, float loadFactor) {        ...        this.loadFactor = loadFactor;        this.threshold = tableSizeFor(initialCapacity);    }</code></pre><p>initialCapacity 参数传入 tableSizeFor 方法内算出一个扩容触发的 threshold 阈值。</p><blockquote><p>threshold: The next size value at which to resize (capacity * load factor).</p></blockquote><p>先看一下 tableSizeFor 方法，这个方法目的是为了找到<strong>不小于  cap 的最小的 2的幂</strong>。</p><pre><code class="java">    /**     * Returns a power of two size for the given target capacity.     */    static final int tableSizeFor(int cap) {        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }</code></pre><p>这里为什么需要</p><pre><code class="java">int n = cap - 1;</code></pre><p>是因为如果 cap 已经是2 的幂而不减 1，经过下面的位运算之后会得到 cap 的 2 倍。</p><p>这段算法比较抽象，借图表示一下：</p><p><img src="tableSizeFor.jpeg" srcset="/img/loading.gif" alt="tableSizeFor.jpeg"></p><p>因为 Integer 是 32bit ，算法移动到 16bit 的时候最多就是 32 个 1 了，所以最后可能产生负数。</p><p>实际上在构造方法里 threshold 的值并没有乘上load factor，而是推迟到了 put 方法调用的时候，重新更新 threshold 的值。</p><h1 id="插入或更新数据-——-put"><a href="#插入或更新数据-——-put" class="headerlink" title="插入或更新数据 —— put"></a>插入或更新数据 —— put</h1><h2 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h2><pre><code class="java">  public V put(K key, V value) {        return putVal(hash(key), key, value, false, true);    }</code></pre><p>put 方法是最复杂的地方之一，虽然入口方法只有一行代码…</p><p>首先重新对传入的 key 进行 hash 计算。</p><pre><code class="java">  /**     * Computes key.hashCode() and spreads (XORs) higher bits of hash     * to lower.  Because the table uses power-of-two masking, sets of     * hashes that vary only in bits above the current mask will     * always collide. (Among known examples are sets of Float keys     * holding consecutive whole numbers in small tables.)  So we     * apply a transform that spreads the impact of higher bits     * downward. There is a tradeoff between speed, utility, and     * quality of bit-spreading. Because many common sets of hashes     * are already reasonably distributed (so don&#39;t benefit from     * spreading), and because we use trees to handle large sets of     * collisions in bins, we just XOR some shifted bits in the     * cheapest possible way to reduce systematic lossage, as well as     * to incorporate impact of the highest bits that would otherwise     * never be used in index calculations because of table bounds.     */    static final int hash(Object key) {        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }</code></pre><p>这里为什么要重新计算一次 hash 而不使用原来的？这个和 table 的 index 计算有关。</p><pre><code class="java">n = table.length;index = （n-1） &amp; hash;</code></pre><p>假设 table.length=2^4=16，经过计算会发现只有后 4 位参与了运算。</p><p><img src="hash%E6%96%B9%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="hash方法.jpeg"></p><p>因为数据表长度是 2 的幂，在没有高位参与运算的时候，特别在数据表较短的时候容易产生碰撞，方案考虑现在 hashcode 比较成熟，综合性能与效率，仅做一次高低位异或就可以减少大部分冲突。</p><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>在 putVal 之前先研究一下 resize 容量调整方法，在这个方法里不只是扩容这么简单，它主要做了：</p><ul><li>table 初始化</li><li>扩容复制</li><li>拆分链表、红黑树，提高查询效率</li></ul><pre><code class="java">/**     * Initializes or doubles table size.  If null, allocates in     * accord with initial capacity target held in field threshold.     * Otherwise, because we are using power-of-two expansion, the     * elements from each bin must either stay at same index, or move     * with a power of two offset in the new table.     *     * @return the table     */    final Node&lt;K,V&gt;[] resize() {        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;        int oldThr = threshold;        int newCap, newThr = 0;        if (oldCap &gt; 0) {            //已经初始化过了            if (oldCap &gt;= MAXIMUM_CAPACITY) {                //防止越界                threshold = Integer.MAX_VALUE;                return oldTab;            }            //1.扩大新容量为原来的两倍。为了实现右移一位就能乘以 2 的操作，所以容量要设置为 2 的幂。            //2.如果新容量小于最大容量，并且旧容量大于默认初始容量（16），更新新的阈值到原来两倍            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                newThr = oldThr &lt;&lt; 1; // double threshold        }        else if (oldThr &gt; 0) // initial capacity was placed in threshold            // 只有 table初始化的时候才会进入这个分支，新容量跟构造时候算出来的阈值一样            newCap = oldThr;        else {               // zero initial threshold signifies using defaults            // 也是table初始化的时候，但是构造时候没有设置阈值，使用默认的容量和阈值。            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        }        if (newThr == 0) {            // 根据新容量更新新的阈值，上文构建方法的时候提到过            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        threshold = newThr;        //根据新容量创建新的 table 数组        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        table = newTab;        if (oldTab != null) {            //开始复制旧的数据到新数组上            //复制时候需要保证元素还在原来的 index 上，或者以 2 次幂偏量移动            for (int j = 0; j &lt; oldCap; ++j) {                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) {                    //释放旧 table 的引用                    oldTab[j] = null;                    if (e.next == null)                        // 如果是普通节点，直接计算 e 在新数组上的 index                        newTab[e.hash &amp; (newCap - 1)] = e;                    else if (e instanceof TreeNode)                        //拆分树节点或者取消树化，将子树或者节点分摊在新table对应的位置上                        //目的：容量大了就不需要这么高的树了，提高查询效率                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else { // preserve order                        // 这里做链表的拆分，链表拆成高低位 2 个。                        Node&lt;K,V&gt; loHead = null, loTail = null;                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;                        do {                            next = e.next;                            if ((e.hash &amp; oldCap) == 0) {                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }                        } while ((e = next) != null);                        if (loTail != null) {                            loTail.next = null;                            //低位链表在原来的位置                            newTab[j] = loHead;                        }                        if (hiTail != null) {                            hiTail.next = null;                            // 高位链表增加 oldCap 偏移拆分到新的位置上                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }</code></pre><h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><p>put 方法最终调用到 putVal 中，</p><pre><code class="java">/**     * Implements Map.put and related methods     *     * @param hash hash for key     * @param key the key     * @param value the value to put     * @param onlyIfAbsent if true, don&#39;t change existing value     * @param evict if false, the table is in creation mode.     * @return previous value, or null if none     */    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        ...</code></pre><p>table 是一个 Node&lt;K,V&gt;数组，如果是第一次 put 或者数据为空则先进行resize ，得到当前的容量 n 。</p><pre><code class="java"> if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);</code></pre><p>计算插入点 hash 在 table 对应的 index ，如果不存在（不冲突）则直接插入新的 Node。</p><p>如果存在冲突，则有 4 种情况：</p><ol><li>key或者 hash 相同，直接更新；</li><li>插入或更新红黑树；</li><li>插入或更新链表；</li><li>链表转红黑树；</li></ol><pre><code class="java"> Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp;     ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))     //1. hash 和 key 相同或者 key equal，后面直接更新值就可以     e = p; else if (p instanceof TreeNode)    //2. 原来的节点已经是红黑树了，那么插入或更新红黑树     e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else {    //3. 尝试插入链表     for (int binCount = 0; ; ++binCount) {         if ((e = p.next) == null) {             p.next = newNode(hash, key, value, null);            // 4. 如果链表长度大于阈值TREEIFY_THRESHOLD（8），则把链表转成红黑树             if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                 treeifyBin(tab, hash);             break;         }         if (e.hash == hash &amp;&amp;             ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))            // 链表有相同的节点了，更新值就可以             break;         p = e;     } } if (e != null) { // existing mapping for key     V oldValue = e.value;     if (!onlyIfAbsent || oldValue == null)        // 更新新的数据         e.value = value;     afterNodeAccess(e);     return oldValue; }</code></pre><p>最后插入或更新完成后，根据阈值判断是否需要扩容。</p><pre><code class="java">if (++size &gt; threshold)       resize();</code></pre><h1 id="获取数据-——-get"><a href="#获取数据-——-get" class="headerlink" title="获取数据 —— get"></a>获取数据 —— get</h1><p>相对 put ，get 的流程就很简单了，无非就是计算 hash 直接去对应位置取，如果是链表或红黑树就进行查找。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>HashMap 的代码格式实在是一言难尽，可读性较差。</p><p>看完之后对一些面试常见的问题也有了答案，例如</p><blockquote><p>构建 HashMap 传入容量 100 和加载因子 0.75 ，put 的时候放入 95 个数据，会触发扩容吗？</p></blockquote><p>答案是不会，因为在构建时 threshold 被计算为 128。首次put的时候，table 初始化的大小等于 threshold ，threshold 的值被更新为 128 * 0.75 = 96 ，所以 put 95 个数据不会触发扩容。</p><p>todo：hash 冲突的算法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
      <tag>源码</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记Android消息处理机制和同步屏障</title>
    <link href="/2020/04/25/%E5%B0%8F%E8%AE%B0Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/"/>
    <url>/2020/04/25/%E5%B0%8F%E8%AE%B0Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<p>代码版本： <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30" target="_blank" rel="noopener">Android-10.0.0_r30</a></p><h1 id="消息处理架构"><a href="#消息处理架构" class="headerlink" title="消息处理架构"></a>消息处理架构</h1><p>在Java层上，Android实现消息处理机制主要有以下几个类：</p><ul><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Handler.java" target="_blank" rel="noopener">android/os/Handler.java</a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Message.java" target="_blank" rel="noopener">android/os/Message.java</a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Looper.java" target="_blank" rel="noopener">android/os/Looper.java</a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="noopener">android/os/MessageQueue.java</a></li></ul><p>虽然它们之间的关系比较简单，但如果要深究其原理还是非常复杂的，特别是到native层部分。</p><p><img src="%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" alt="消息机制架构.png"></p><p>如图所示，Handler负责处理消息，类似一个句柄，其他线程可以向其发送 Message ， Message 进入消息队列 MessageQueue 中，一个运行在主线程的 Looper 不断从队列中取出消息，然后调用其 Handler 或者 Callback 处理逻辑。</p><h1 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h1><h2 id="构建Looper"><a href="#构建Looper" class="headerlink" title="构建Looper"></a>构建Looper</h2><p>Looper 的内部维护了一个 MessageQueue 对象，在线程中调用 Looper.prepare 来创建新的 Looper。</p><pre><code class="java">class LooperThread extends Thread {      Handler handler;      public void run() {          // 必须先调用          Looper.prepare();          //用 Looper 来创建 Handler          handler = new Handler(Looper.myLooper());          Looper.loop();      } }</code></pre><p>Looper#prepare 方法里，构建一个新的 Looper 对象，然后将其放入静态的<br> sThreadLocal 中。</p><blockquote><p>ThreadLocal: This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. </p></blockquote><p>如果重复调用 prepare 会抛出异常，所以<strong>每个线程只能有一个 Looper</strong>。</p><p>在主线程（UI Thread）中不需要创建 Looper，因为在应用 ActivityThread 创建出来的时候，在 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/app/ActivityThread.java;l=7329;drc=0a9ee1af2cba8da1de3aace999d8547503c06f4c" target="_blank" rel="noopener">main</a> 方法中已经调用过 Looper#prepareMainLooper 了。</p><pre><code class="java">private static void prepare(boolean quitAllowed) {        if (sThreadLocal.get() != null) {            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);        }        sThreadLocal.set(new Looper(quitAllowed));    }</code></pre><p>最后调用 Looper#loop 方法，创建一个 MessageQueue 并循环等待调用其 next 方法得到下一条要被处理的消息，将这个消息分发给对应的处理者。</p><pre><code class="java">public static void loop() {        final Looper me = myLooper();        ...        final MessageQueue queue = me.mQueue;        ...        for (;;) {            Message msg = queue.next(); // might block            ...            // 分发事件给 target 处理，也就是消息对应的 Handler            msg.target.dispatchMessage(msg);             ...            // 回收 Message            msg.recycleUnchecked();        }        ...}</code></pre><p>到这里Looper 的主要工作就结束了。</p><h2 id="构建Handler"><a href="#构建Handler" class="headerlink" title="构建Handler"></a>构建Handler</h2><p>Handler 的构建必须依赖 Looper 作为参数，否则就是无效 Handler，即使在主线程创建，Google 官方还是推荐使用以 Looper 作为参数的构建方式来创建 Handler，</p><pre><code class="java">Handler h = new Handler(Looper.getMainLooper());</code></pre><p>在新版的代码中可以看到，Handler 的无参构建方法已经标记为 Deprecated 了，目的是避免错误隐患和保证代码可读性。</p><p>Handler 还有几个被 hide 的构造方法，和异步消息有关，后续继续分析。</p><pre><code class="java">    /**    * @hide    */    public Handler(boolean async) {        this(null, async);    }</code></pre><h2 id="Handler-处理消息"><a href="#Handler-处理消息" class="headerlink" title="Handler 处理消息"></a>Handler 处理消息</h2><p>Handler 的 dispatchMessage 方法负责接收 Looper 分发的消息，可以看到消息处理的优先级：</p><p>Message 内的 callback &gt; Handler 的 callback &gt; handleMessage 方法</p><pre><code class="java"> public void dispatchMessage(@NonNull Message msg) {        if (msg.callback != null) {            handleCallback(msg); // 1        } else {            if (mCallback != null) {                // 2                if (mCallback.handleMessage(msg)) {                    return;                }            }            handleMessage(msg); // 3        }    }</code></pre><h1 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h1><h2 id="构造-Message"><a href="#构造-Message" class="headerlink" title="构造 Message"></a>构造 Message</h2><p>构造一个 Message 对象可以直接 new 一个出来，但是一般都使用 Message.obtain() 从对象池中获取，否则如果消息频率太高会导致短时间内存占用上升，虚拟机频繁 <a href="https://hoholidayx.github.io/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B3%95">GC</a>  影响性能。</p><p>Message 其实是链表结构，</p><pre><code class="java">public final class Message implements Parcelable {    ...    public int what;    ...    // sometimes we store linked lists of these things    /*package*/ Message next;    ...    // 对象池起始当前节点    private static Message sPool;}</code></pre><p>使用一个静态 sPool 变量表示当前对象池链表的头节点，通过 obtain 方法获取 Message 的时候把头结点从链表移除。</p><pre><code class="java">    public static Message obtain() {        synchronized (sPoolSync) {            if (sPool != null) {                Message m = sPool;                sPool = m.next;                m.next = null;                m.flags = 0; // clear in-use flag                sPoolSize--;                return m;            }        }        return new Message();    }</code></pre><p>Message 使用完后调用 recycle 方法进入 recycleUncheckd ，将当前Message插入回链表头部。</p><pre><code class="java">            if (sPoolSize &lt; MAX_POOL_SIZE) {                next = sPool;                sPool = this;                sPoolSize++;            }</code></pre><p>所以实际上这个对象池是一个用链表实现的栈。</p><h2 id="通过-Handler-发送-Message"><a href="#通过-Handler-发送-Message" class="headerlink" title="通过 Handler 发送 Message"></a>通过 Handler 发送 Message</h2><p>调用 Handler 的 sendMessage 方法，最后到 sendMessageAtTime 中，向 MessageQueue 入队消息。</p><pre><code class="java"> private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,            long uptimeMillis) {        msg.target = this;        msg.workSourceUid = ThreadLocalWorkSource.getUid();        //异步消息        if (mAsynchronous) {            msg.setAsynchronous(true);        }        //消息入队        return queue.enqueueMessage(msg, uptimeMillis);    }</code></pre><h2 id="在-MessageQueue-中插入-Message"><a href="#在-MessageQueue-中插入-Message" class="headerlink" title="在 MessageQueue 中插入 Message"></a>在 MessageQueue 中插入 Message</h2><p>在 enqueueMessage 中主要做了几件事：</p><ol><li>将消息标记为已使用；</li><li>按照消息的发送时间 （uptimeMillis）将消息插入队列中的对应位置；</li><li>判断是否要 wakeup 一次 next 方法的等待；</li></ol><pre><code class="java"> boolean enqueueMessage(Message msg, long when) {        if (msg.target == null) {            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);        }        if (msg.isInUse()) {            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);        }        synchronized (this) {            if (mQuitting) {                IllegalStateException e = new IllegalStateException(                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);                Log.w(TAG, e.getMessage(), e);                msg.recycle();                return false;            }            // 标记消息为已使用            msg.markInUse();            msg.when = when;            Message p = mMessages;            boolean needWake;            if (p == null || when == 0 || when &lt; p.when) {                // 队列为空，或者需要立即发送或发送时间快于队首                // New head, wake up the event queue if blocked.                msg.next = p;                mMessages = msg;                needWake = mBlocked;//有新的消息，如果当前是 block 状态则需要 wakeup            } else {                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake                // up the event queue unless there is a barrier at the head of the queue                // and the message is the earliest asynchronous message in the queue.                // 除非是当前队首是同步屏障，并且这个消息是最早的异步消息，否则不需要 wakeup                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();                Message prev;                // 循环找到发送时间大于当前消息的节点，将其插入找到的这个节点之前                for (;;) {                    prev = p;                    p = p.next;                    if (p == null || when &lt; p.when) {                        break;                    }                    //如果后面的节点有异步消息，则这一次插入不需要wakeup                    if (needWake &amp;&amp; p.isAsynchronous()) {                        needWake = false;                    }                }                msg.next = p; // invariant: p == prev.next                prev.next = msg;            }            // We can assume mPtr != 0 because mQuitting is false.            if (needWake) {                nativeWake(mPtr);            }        }        return true;    }</code></pre><h2 id="MessageQueue-next-返回给-Looper-消息"><a href="#MessageQueue-next-返回给-Looper-消息" class="headerlink" title="MessageQueue.next 返回给 Looper 消息"></a>MessageQueue.next 返回给 Looper 消息</h2><p>next 方法有个大循环持续 wait &amp; get ，直到队列中取出合适的消息返回给 Looper 使用。</p><pre><code class="java">        int nextPollTimeoutMillis = 0;        for (;;) {            ...            //该方法会持续 block，直到超时或者被 nativeWake 方法唤醒            nativePollOnce(ptr, nextPollTimeoutMillis);            synchronized (this) {                // Try to retrieve the next message.  Return if found.                final long now = SystemClock.uptimeMillis();                Message prevMsg = null;                Message msg = mMessages;                //和异步消息有关，后续分析                if (msg != null &amp;&amp; msg.target == null) {                    // Stalled by a barrier.  Find the next asynchronous message in the queue.                    do {                        prevMsg = msg;                        msg = msg.next;                    } while (msg != null &amp;&amp; !msg.isAsynchronous());                }                if (msg != null) {                    if (now &lt; msg.when) {                        //如果取出来的时间还没到，更新nextPollTimeoutMillis继续调用nativePollOnce等待                        // Next message is not ready.  Set a timeout to wake up when it is ready.                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                    } else {                        // Got a message.                        mBlocked = false;                        //将消息从队列中移除                        if (prevMsg != null) {                            prevMsg.next = msg.next;                        } else {                            mMessages = msg.next;                        }                        msg.next = null;                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);                        msg.markInUse();                        return msg;                    }                } else {                    // No more messages.                    nextPollTimeoutMillis = -1;                }        ...        }        ...</code></pre><h1 id="消息同步屏障"><a href="#消息同步屏障" class="headerlink" title="消息同步屏障"></a>消息同步屏障</h1><h2 id="什么是同步屏障"><a href="#什么是同步屏障" class="headerlink" title="什么是同步屏障"></a>什么是同步屏障</h2><p>同步屏障是 MeesageQueue 中一种特殊的机制，源码注释如下，</p><blockquote><p>Message processing occurs as usual until the message queue encounters the<br>synchronization barrier that has been posted.  When the barrier is encountered,<br>later synchronous messages in the queue are stalled (prevented from being executed) until the barrier is released by calling {@link #removeSyncBarrier} and specifying the token that identifies the synchronization barrier.</p></blockquote><p>大概意思就是同步屏障是阻碍正常消息队列循环的一种手段，这个屏障会阻碍同步消息也就是平时我们发送的消息的循环，而异步消息还是正常发送，所以异步消息和同步屏障通常是搭配使用的。如下图所示：</p><p><img src="%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C.png" srcset="/img/loading.gif" alt="同步屏障.png"></p><p>同步屏障的意义简单来说，就像游戏服务器拥挤的时候，异步消息就是 VIP 玩家可以优先登录游戏，而普通玩家需要等到服务器缓解的时候才能登录。实际上在 Android 中，同步屏障的意义也是在于此，例如屏幕的绘制信号。</p><h2 id="同步屏障实现"><a href="#同步屏障实现" class="headerlink" title="同步屏障实现"></a>同步屏障实现</h2><h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>调用 MessageQueue 的 postSyncBarrier 放置一个同步屏障，when 参数指定屏障发生的时间。</p><pre><code class="java"> private int postSyncBarrier(long when) {        // Enqueue a new sync barrier token.        // We don&#39;t need to wake the queue because the purpose of a barrier is to stall it.        synchronized (this) {            final int token = mNextBarrierToken++;            final Message msg = Message.obtain();            msg.markInUse();            msg.when = when;            msg.arg1 = token;            Message prev = null;            Message p = mMessages;            if (when != 0) {                while (p != null &amp;&amp; p.when &lt;= when) {                    prev = p;                    p = p.next;                }            }            if (prev != null) { // invariant: p == prev.next                msg.next = p;                prev.next = msg;            } else {                msg.next = p;                mMessages = msg;            }            return token;        }    }</code></pre><p>从源码可以看出其实这个屏障就是一个特殊的 Message，它没有对应的 Handler，所以 target 为空，这条消息的插入逻辑和普通消息的插入是一样，但是这个插入不会唤醒 block 住的 poll 循环。</p><h3 id="处理屏障"><a href="#处理屏障" class="headerlink" title="处理屏障"></a>处理屏障</h3><p>同步屏障也是在 next 方法中实现的，上文 next 的源码中有一段：</p><pre><code class="java">                // Try to retrieve the next message.  Return if found.                final long now = SystemClock.uptimeMillis();                Message prevMsg = null;                Message msg = mMessages;                if (msg != null &amp;&amp; msg.target == null) {                    // Stalled by a barrier.  Find the next asynchronous message in the queue.                  // 在这里实现同步屏障。如果当前队首消息是屏障消息（target==null），那么就循环寻找下一条异步消息取出队列。                    do {                        prevMsg = msg;                        msg = msg.next;                    } while (msg != null &amp;&amp; !msg.isAsynchronous());                }</code></pre><p>代码很短，很巧妙的就实现了这样的一个重要的功能。</p><h3 id="移除屏障"><a href="#移除屏障" class="headerlink" title="移除屏障"></a>移除屏障</h3><p>放置了同步屏障一定要在合适的时候进行移除，例如期望的异步消息得到了回调，不然这个屏障会一直存在，导致正常的同步消息无法正常回调！</p><p>通过调用 removeSyncBarrier 方法进行移除，传入 postSyncBarrier 返回的 token 作为参数，标识需要移除哪个屏障，然后将该屏障消息会从队列中移除。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>到此 Java 层的消息机制实现基本分析完毕了，代码虽然不多架构也比较简单，但不失为学习阅读 Android 源码的好例子。</p><p>在 Android2.3 之前是只有 Java 层上有这套代码，在之后 Native 层也实现了一套类似的机制，本文还没有对 native 部分代码进行深究，后续有时间会继续更新。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>消息机制</tag>
      
      <tag>源码</tag>
      
      <tag>Handler</tag>
      
      <tag>Message</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下搭建CUDA+cuDNN+tf+Python环境</title>
    <link href="/2020/04/22/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BACUDA+cuDNN+tf+Python%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/04/22/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BACUDA+cuDNN+tf+Python%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="安装NVIDIA-CUDA"><a href="#安装NVIDIA-CUDA" class="headerlink" title="安装NVIDIA CUDA"></a>安装NVIDIA CUDA</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>Ubuntu：16.0.4</li><li>Toolkit：10.0</li><li>cuDNN：7.5.1 (April 22, 2019) for CUDA 10.0</li></ul><ol><li><a href="https://developer.nvidia.com/cuda-10.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=runfilelocal" target="_blank" rel="noopener">官网下载CUDA Toolkit</a></li></ol><p>安装cuda之前需要先安装gcc、g++和 build-essential等。</p><pre><code class="shell">sudo apt-get install build-essential gcc g++ make binutils linux-headers-`uname -r`</code></pre><p>运行安装脚本即可</p><pre><code class="shell">sudo sh cuda_10.0.130_410.48_linux.run</code></pre><p>配置CUDA环境变量</p><pre><code class="shell">export PATH=/usr/local/cuda-10.0/bin${PATH:+:${PATH}}export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}source ~/.bashrc</code></pre><ol start="2"><li><a href="https://developer.nvidia.com/rdp/form/cudnn-download-survey" target="_blank" rel="noopener">下载</a>cuDNN</li></ol><ul><li><p><a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v7.5.1/prod/10.0_20190418/Ubuntu16_04-x64/libcudnn7-dev_7.5.1.10-1%2Bcuda10.0_amd64.deb" target="_blank" rel="noopener">dev包</a></p></li><li><p><a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v7.5.1/prod/10.0_20190418/Ubuntu16_04-x64/libcudnn7_7.5.1.10-1%2Bcuda10.0_amd64.deb" target="_blank" rel="noopener">runtime包</a></p></li></ul><p>安装</p><pre><code class="shell">dpkg -i libcudnn7-dev_7.5.1.10-1%2Bcuda10.0_amd64.debdpkg -i libcudnn7_7.5.1.10-1%2Bcuda10.0_amd64.deb</code></pre><h1 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h1><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><ol><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官网</a>下载需要的版本</li><li>将源码解压缩，进入到目录内编译安装</li></ol><pre><code class="shell">./configuremakemake install</code></pre><h2 id="通过PPA源安装Python"><a href="#通过PPA源安装Python" class="headerlink" title="通过PPA源安装Python"></a>通过PPA源安装Python</h2><pre><code class="shell">sudo apt-get install software-properties-commonsudo add-apt-repository ppa:deadsnakes/ppasudo apt-get updatesudo apt-get install python3.6 python3-pippython3.6 -m pip install [Package_to_install]</code></pre><h1 id="安装Tensorflow-gpu"><a href="#安装Tensorflow-gpu" class="headerlink" title="安装Tensorflow-gpu"></a>安装Tensorflow-gpu</h1><p>按照上面的cuda和cuDNN版本，这里只能装1.14.0的，不然会提示与cuDNN版本不兼容。</p><pre><code class="shell">python3.6 -m pip install tensorflow==1.14.0 tensorflow-gpu==1.14.0</code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Ubuntu进行StyleGAN2训练Google Colab版</title>
    <link href="/2020/03/31/%E5%9C%A8Ubuntu%E8%BF%9B%E8%A1%8CStyleGAN2%E8%AE%AD%E7%BB%83Google%20Colab%E7%89%88/"/>
    <url>/2020/03/31/%E5%9C%A8Ubuntu%E8%BF%9B%E8%A1%8CStyleGAN2%E8%AE%AD%E7%BB%83Google%20Colab%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h1><ul><li>稳定的梯子</li><li>谷歌账号(有钱最好，新用户可以试用300$)</li><li>训练集</li></ul><h1 id="准备训练集"><a href="#准备训练集" class="headerlink" title="准备训练集"></a>准备训练集</h1><p>如果只想走一下流程的话，随便准备百来张图片就可以了，毕竟跑一次训练成本很高，支持的图片尺寸有256x256，512x512和1024x1024。</p><p>推荐一个国内的网站<a href="http://www.seeprettyface.com/" target="_blank" rel="noopener">seeprettyface</a>，有不少产品和免费的图库下载。</p><p>StyleGAN2不能支持直接输入图片，需要用官方提供的dataset_tool.py将原始图片转换成Tensorflow的tfrecords格式，会占用更大的空间，所以需要预留好硬盘。</p><h1 id="下载StyleGAN2源码"><a href="#下载StyleGAN2源码" class="headerlink" title="下载StyleGAN2源码"></a>下载StyleGAN2源码</h1><pre><code class="shell">%tensorflow_version 1.x!git clone https://github.com/NVlabs/stylegan2%cd stylegan2</code></pre><p>outputs:</p><pre><code class="shell">Cloning into &#39;stylegan2&#39;...remote: Enumerating objects: 7, done.remote: Counting objects: 100% (7/7), done.remote: Compressing objects: 100% (7/7), done.remote: Total 117 (delta 2), reused 3 (delta 0), pack-reused 110Receiving objects: 100% (117/117), 587.49 KiB | 21.76 MiB/s, done.Resolving deltas: 100% (47/47), done./content/stylegan2</code></pre><h2 id="源码修改"><a href="#源码修改" class="headerlink" title="源码修改"></a>源码修改</h2><h3 id="如发生错误C-versions-less-than-C-11-are-not-supported"><a href="#如发生错误C-versions-less-than-C-11-are-not-supported" class="headerlink" title="如发生错误C++ versions less than C++11 are not supported"></a>如发生错误C++ versions less than C++11 are not supported</h3><p>修改文件  dnnlib/tflib/custom_ops.py：</p><pre><code class="python">cmd = opts.strip()</code></pre><p>改为</p><pre><code class="python">cmd = &#39;nvcc --std=c++11 -DNDEBUG &#39; + opts.strip()</code></pre><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="一般虚拟机-GPU"><a href="#一般虚拟机-GPU" class="headerlink" title="一般虚拟机(GPU)"></a>一般虚拟机(GPU)</h2><p>配置StyleGAN2的运行环境主要需要以下几点：</p><ol><li><a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener">NVIDIA CUDA Toolkit(含驱动)</a></li><li><a href="https://developer.nvidia.com/rdp/form/cudnn-download-survey" target="_blank" rel="noopener">NVIDIA cuDNN (需要登录)</a></li><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python3.6</a></li><li><a href="https://www.tensorflow.org/install/gpu" target="_blank" rel="noopener">Tensorflow-gpu</a></li></ol><p>这些东西的配置逛网和网上都有很多教程了，安装的顺序按照上述就行。</p><p>如果是阿里云的服务器，不要选择“GPU虚拟化”的类型，驱动各种装不上，选“GPU计算型”即可，懒的话还可以用阿里提供的<a href="https://help.aliyun.com/document_detail/60149.html?spm=5176.ecsbuyv3.0.0.c5c23675LahT5D#section-bl2-k23-ygb" target="_blank" rel="noopener">自动安装脚本</a>安装驱动+cuda+cnDUU。</p><p><strong>其他python依赖</strong>：</p><ul><li>numpy</li><li>scipy==1.3.3</li><li>requests==2.22.0</li><li>Pillow==6.2.1</li></ul><h2 id="Google-Colab"><a href="#Google-Colab" class="headerlink" title="Google Colab"></a>Google Colab</h2><ol><li>将数据集放到Drive内</li><li>挂载 Google Drive</li><li><del>充值 Google Colab Pro</del></li></ol><pre><code class="python">#挂载 Google Drivefrom google.colab import drivedrive.mount(&#39;/content/drive&#39;)</code></pre><p>outputs:</p><pre><code class="shell">Go to this URL in a browser: [https://accounts.google.com/o/oauth2/auth?client_id=...) Enter your authorization code: ·········· Mounted at /content/drive</code></pre><h1 id="转换图片为数据集"><a href="#转换图片为数据集" class="headerlink" title="转换图片为数据集"></a>转换图片为数据集</h1><p>因为StyleGAN2不能直接输入原始图片，所以需要转成tfrecords格式。</p><p>python dataset_tool.py create_from_images  <strong>TF_RECORD的输出路径</strong>   <strong>输入的图片集合</strong></p><pre><code class="shell">!python dataset_tool.py create_from_images /content/drive/My\ Drive/download/datasets/mysets /content/drive/My\ Drive/download/images</code></pre><p>outputs:</p><pre><code class="shel">Loading images from &quot;/content/drive/My Drive/download/images&quot;Creating dataset &quot;/content/drive/My Drive/download/images_tf_records&quot;Added 151 images.</code></pre><h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><h2 id="检查运行环境"><a href="#检查运行环境" class="headerlink" title="检查运行环境"></a>检查运行环境</h2><pre><code class="python"># 检查运行环境!nvcc test_nvcc.cu -o test_nvcc -run!nvidia-smi -Limport tensorflow as tfprint(&#39;Tensorflow version: {}&#39;.format(tf.__version__) )print(&#39;GPU Identified at: {}&#39;.format(tf.test.gpu_device_name()))</code></pre><p>outputs:</p><pre><code class="shell">CPU says hello.GPU says hello.Tensorflow version: 1.15.0GPU 0: Tesla P100-PCIE-16GB (UUID: GPU-99160cdb-b950-8328-38c2-b9a0b9128643)GPU Identified at: /device:GPU:0</code></pre><h2 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h2><p>run_training.py有3个必须配置的参数：</p><ul><li>config 训练配置项</li><li>data-dir 训练集的位置,例如 /datasets</li><li>dataset 训练集内的子文件夹名字，例如完整路径是/datasets/mysets，这里就输入mysets，</li></ul><p>config：不同的配置影响会训练的时间，具体参见<a href="https://github.com/hoholidayx/stylegan2" target="_blank" rel="noopener">官方文档</a></p><table><thead><tr><th>config</th><th>desc</th></tr></thead><tbody><tr><td>config-a</td><td>Baseline StyleGAN</td></tr><tr><td>config-b</td><td>Weight demodulation</td></tr><tr><td>config-c</td><td>Lazy regularization</td></tr><tr><td>config-d</td><td>Path length regularization</td></tr><tr><td>config-e</td><td>No growing, new G &amp; D arch.</td></tr><tr><td>config-f</td><td>Large networks (default)</td></tr></tbody></table><p>total-kimg：训练的循环次数，默认是25000</p><h2 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h2><pre><code class="shell"># 开始训练!python ./run_training.py --config &quot;config-f&quot; --total-kimg 10000 --dataset &quot;mysets&quot; --data-dir &quot;/content/drive/My Drive/download/datasets&quot;</code></pre><h1 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h1><p>colab内存不够，看来还是要充值。</p><blockquote><p>tick 0     kimg 0.0      lod 0.00  minibatch 4    time 18s          sec/tick 17.8    sec/kimg 1114.10 </p></blockquote><p>sec/kimg 表示每次循环需要的时间，在GCP上，4 CPUs 、26 GB Mem &amp; K80 GPU，大概时间是 900秒，仅供参考。</p><p>模型训练完后默认保存到results目录下，results/00xxx-stylegan2-{dataset}-{gpu}-{config}/network-final.pkl。</p><h1 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h1><p>这一步骤没有做，因为只是为了过一遍流程和踩坑，具体可以参考<a href="https://github.com/NVlabs/stylegan2#evaluation-metrics" target="_blank" rel="noopener">官方文档</a>，比较简单。</p><pre><code class="shell">python run_metrics.py --data-dir=/content/drive/My\ Drive/download/datasets \ --network=stylegan2/results/00000-stylegan2-myset-1gpu-config-f/network-final.pkl \  --metrics=fid50k,ppl2_wend --dataset=myset</code></pre><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><pre><code class="shell">python3.6 run_generator.py generate-images --network=stylegan2/results/00000-stylegan2-myset-1gpu-config-f/network-final.pkl \  --seeds=66,230,389,1518 --truncation-psi=1.0</code></pre><p>根据seeds得到4个结果：</p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png" srcset="/img/loading.gif" alt="运行结果1.png"></p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png" srcset="/img/loading.gif" alt="运行结果2.png"></p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C3.png" srcset="/img/loading.gif" alt="运行结果3.png"></p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C4.png" srcset="/img/loading.gif" alt="运行结果4.png"></p><p>因为这次运行的训练集数量很少，循环次数也很少，所以得到的结果也只能如上所示，但是还是依稀可以看到图片的轮廓的。</p><p>如果训练时间足够样本足够的话，正常的过程应该是这样的：</p><p><img src="%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B.gif" srcset="/img/loading.gif" alt="训练过程.gif"></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>完整ipynb<a href="https://colab.research.google.com/drive/18TFQScGlCD0WnjAXwPrgcr_KMzcryJ3y" target="_blank" rel="noopener">下载</a>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>StyleGAN</tag>
      
      <tag>机器学习</tag>
      
      <tag>AI</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Android游戏助手</title>
    <link href="/2020/03/17/%E5%85%B3%E4%BA%8EAndroid%E6%B8%B8%E6%88%8F%E5%8A%A9%E6%89%8B/"/>
    <url>/2020/03/17/%E5%85%B3%E4%BA%8EAndroid%E6%B8%B8%E6%88%8F%E5%8A%A9%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏助手是什么"><a href="#游戏助手是什么" class="headerlink" title="游戏助手是什么"></a>游戏助手是什么</h1><p>终于开始这个系列的填坑了，自上次17年写的文章<a href="https://hoholidayx.github.io/2017/10/08/LuaJava%E5%9C%A8Java%E3%80%81Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">《LuaJava在Java、Android中的使用》</a> 已经过了2年，主要介绍了游戏助手技术栈的其中一项。本文开始将继续记录一些项目中碰到的问题和有价值的经验。<del>项目坟头都长草了祭奠一下。</del></p><p><img src="%E5%BF%83%E5%A1%9E.jpg" srcset="/img/loading.gif" alt="心塞"></p><p>这里游戏助手主要指的是Android端的应用，虽然iOS端也有能够实现的方案，但是成本较高且本人对iOS技术钻研不精，所以不做讨论。</p><p>游戏助手是什么，用我的定义来说，就是</p><ol><li><strong>能帮助玩家自动的去完成一些冗余重复的工作</strong>，例如挂机刷金币，</li><li><strong>或者是增强补充游戏内的某些功能</strong>，例如魔兽世界伤害统计的辅助工具软件。</li></ol><p>下图展示的是<a href="https://cfm.qq.com/" target="_blank" rel="noopener">穿越火线手游</a>自动操作塔防。</p><p><img src="cf%E8%87%AA%E5%8A%A8%E6%B8%B8%E6%88%8F.gif" srcset="/img/loading.gif" alt="cf自动游戏.gif"></p><p><a href="https://pvp.qq.com/" target="_blank" rel="noopener">王者荣耀</a>自动刷冒险设置。</p><p><img src="%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E8%87%AA%E5%8A%A8%E5%88%B7%E5%86%92%E9%99%A9%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="王者荣耀自动刷冒险设置"></p><p>这里可能有人会说“这不就是WG嘛”，对的，这东西俗称其实就是WG，但是在这里不讨论什么“道德伦理”问题，技术本身没有好坏，关键在于怎么去使用它。</p><p>在移动端实现游戏助手辅助功能主要有两个流派，以是否读写内存作区分：</p><ul><li>不读写内存</li></ul><p><img src="%E4%B8%8D%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98.jpg" srcset="/img/loading.gif" alt="不读写内存"></p><ul><li>读写内存</li></ul><p><img src="%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98.jpg" srcset="/img/loading.gif" alt="读写内存"></p><h1 id="市面上的产品"><a href="#市面上的产品" class="headerlink" title="市面上的产品"></a>市面上的产品</h1><p>18年再往之前，可以说是这个领域的黄金时期，有着各式各样的种游戏辅助软件，其中时间较长用户规模也比较大的有叉叉助手，还有在末期才出现的游戏超人等，我研究比较多的也就这俩，下面也就拿这两家和我厂的产品来介绍。</p><table><thead><tr><th>产品</th><th>是否需要root</th><th>是否读写内存</th><th>核心技术</th></tr></thead><tbody><tr><td>叉叉助手</td><td>有root和非root版本</td><td>否</td><td>高权限adb shell</td></tr><tr><td>游戏超人</td><td>不需要</td><td>否</td><td>悬浮窗、美工</td></tr><tr><td>我厂AY</td><td>不需要</td><td>是</td><td>沙箱虚拟化</td></tr></tbody></table><h2 id="叉叉助手"><a href="#叉叉助手" class="headerlink" title="叉叉助手"></a>叉叉助手</h2><p>叉叉助手是行业内最有资历的产品，<del>所以后面才被杀鸡儆猴</del>，最早应该是在PC端有不少的资源，后续转战移动端，拥有自己的脚本开发者生态圈，这一点是令人向往的。</p><p><img src="%E5%8F%89%E5%8F%89%E5%8A%A9%E6%89%8B.jpeg" srcset="/img/loading.gif" alt="叉叉助手.jpeg"></p><p>叉叉助手支持手机root和非root使用，核心技术是通过获取adb shell的权限，启动自己的守护和工作进程，通过进程间通信实现屏幕的截图和模拟点击等操作，属于上文说的不读写内存的流派1。</p><p>root的情况下就不说了，什么事情都能干，但是用户群比较小；非root的情况就比较复杂，需要引导用户在PC端上下载“钥匙应用”进行APP的“激活”，本质上就是利用手机与pc端的adb连接，来启动手机的shell进程获取权限。</p><h2 id="游戏超人"><a href="#游戏超人" class="headerlink" title="游戏超人"></a>游戏超人</h2><p>游戏超人应该是猎豹做的一款辅助，我知道它的时候已经是末期了，给我的第一印象就是UI很好看很精细，<del>不像我厂的产品很多UI都是我自己动手的，</del>它提供的功能也比较简单，基本都是游戏界面美化之类的，从下图也可以看出。</p><p><img src="%E6%B8%B8%E6%88%8F%E8%B6%85%E4%BA%BA.jpeg" srcset="/img/loading.gif" alt="游戏超人.jpeg"></p><p>经过分析发现，其实它的核心实现非常简单，就是悬浮窗，剩下的就是怎么制作这些美化UI和这些UI怎么去适配游戏和屏幕分辨率的问题了。</p><h2 id="我厂的游戏助手-AY"><a href="#我厂的游戏助手-AY" class="headerlink" title="我厂的游戏助手-AY"></a>我厂的游戏助手-AY</h2><p>我厂的游戏助手项目简称AY好了，这里不方便透露名字。AY的实现方式集合了上文的两种流派来实现的。</p><p><img src="AY.jpg" srcset="/img/loading.gif" alt="AY.jpg"></p><p>AY依靠分身（沙箱）SDK提供的沙箱环境和多个hook接口，实现了对内存的读写，这里主要是为了实现上文的“输出模拟点击”部分；同时使用Android5.0提供的屏幕录制接口，实现“获取屏幕截图”部分。</p><p>这种方式可以结合两种流派的优点，可以在免root的情况下，不需要像叉叉助手一样复杂的用户引导流程，又可以实现对第三方应用的输出模拟点击，所以AY能比同类产品有更强的能力去做更多的事情，后续的产品迭代也证明了这点。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>到了19年之后就开始这些产品就开始凉了（包括我厂的项目），原因有很多，主要因腾讯加强了对作弊的打压，反作弊SDK不断升级攻防难度加大，投入不抵产出，更主要的原因是政府层面出手打压这块产业，其中最惨的就是叉叉助手，<a href="https://www.sohu.com/a/361203096_120123245" target="_blank" rel="noopener">《叉叉助手公司被查！案值数亿元，也成全国首例违法脚本公司》</a>。</p><p><img src="%E9%BB%98%E5%93%80.jpg" srcset="/img/loading.gif" alt="默哀"></p><p>虽然产业消亡了，但是还是沉淀不少的技术，也许未来还能有用武之地的，例如在自动化测试等…</p>]]></content>
    
    
    <categories>
      
      <category>游戏助手</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>游戏</tag>
      
      <tag>辅助</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LuaJava框架多线程支持修改</title>
    <link href="/2020/03/03/LuaJava%E6%A1%86%E6%9E%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E4%BF%AE%E6%94%B9/"/>
    <url>/2020/03/03/LuaJava%E6%A1%86%E6%9E%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>LuaJava框架是不支持多线程调用的，例如在游戏助手里，脚本需要在Java层执行一个异步任务，然后回调通知Lua层，因为Lua是单独跑在一个线程里，而回调是在主线程，所以这时候会发生崩溃或者Lua虚拟机的栈异常。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>这种情况有两种解决方案，一是修改LUA虚拟机，使其在当前线程能够执行post过来的任务，类似Handler，这种方案没有实现;二是在Java层或者JNI层修改，使其线程安全。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  JNI编程和Linux上的C/C++编程还是挺相似的，每次java调用JNI中的函数时都会传入有关JVM的一些参数（如JNIEnv，jobject），每次JNI回调java中的方法时都要通过JVM的有关参数来实现，当在JNI中涉及到多线程的话还是有一些不一样的地方，就是要在子线程函数里使用AttachCurrentThread()和DetachCurrentThread()这两个函数，在这两个函数之间加入回调java方法所需要的代码。</p><p>  JNIEnv是一个线程相关的变量,JNIEnv 对于每个 thread 而言是唯一的,JNIEnv *env指针不可以为多个线程共用。但是Java虚拟机的JavaVM指针是整个jvm公用的，我们可以通过JavaVM来得到当前线程的JNIEnv指针。可以使用javaAttachThread保证取得当前线程的Jni环境变量。</p><h2 id="native层修改"><a href="#native层修改" class="headerlink" title="native层修改"></a>native层修改</h2><ol><li>保存全局的JavaVM指针</li></ol><pre><code class="C">jint JNI_OnLoad(JavaVM* vm, void* reserved) {    ...    //将vm指针保存到全局变量中    set_jvm(vm);    ...}</code></pre><ol start="2"><li>Lua运行时获取当前线程的env</li></ol><p>在 luajava.c的getEnvFromState方法实现里，去更新指针。</p><pre><code class="C">JNIEnv *getEnvFromState(lua_State *L) {    JNIEnv *javaEnv = NULL;    if (g_jvm-&gt;AttachCurrentThread(&amp;javaEnv, NULL) == JNI_OK) {        return javaEnv;    } else {        LOGE(&quot;JavaEnv attach failed!&quot;);        return NULL;    }}</code></pre><h2 id="Java层修改"><a href="#Java层修改" class="headerlink" title="Java层修改"></a>Java层修改</h2><ol start="3"><li>去除同步锁</li></ol><p>在<a href="https://github.com/jasonsantos/luajava/blob/b27d23db7d3b701931ac96740b5a9b05be8d240b/src/java/org/keplerproject/luajava/Console.java#L84" target="_blank" rel="noopener">Console.java</a>中，去除掉pcall的synchronized，否则在整个脚本运行期间，pcall会持续占有luastate的锁，导致其他线程无法获得同步锁，所以无法调用luastate的其他方法。</p><p>这里并不是说完全去除掉同步锁，而是只需要在多线程操作的地方，局部同步LuaState，否则LuaVM栈可能会出错。</p><ol start="4"><li>在 JavaFunction 类，删除掉LuaState L，用全局ThreadLocal来代替存储。</li></ol><p>execute稍作修改，让native调用的时候调的是execute(long)方法，这样在方法执行之前可以做一些事情。</p><pre><code class="Java">    public abstract class JavaFunction {    /**     * This is the state in which this function will exist.     */    //    protected LuaState L;    //用来保存c层lua_state的指针，当需要在对应栈上操作的时候，从这个ThreadLocal取    protected static final ThreadLocal&lt;Long&gt; mLuaStateCPoniter = new ThreadLocal&lt;Long&gt;() {        @Override        protected Long initialValue() {            return (long) 0;        }    };    /**     * This method is called from Lua. Any parameters can be taken with     * &lt;code&gt;getParam&lt;/code&gt;. A reference to the JavaFunctionWrapper itself is     * always the first parameter received. Values passed back as results     * of the function must be pushed onto the stack.     *     * @return The number of values pushed onto the stack.     */    public abstract int execute() throws LuaException;    //native调用这个同步的execute，保证在正确的栈上调用完后才能让其他线程换栈    public int execute(long lua_state) throws LuaException {        mLuaStateCPoniter.set(lua_state);        return execute();    }    /**     * Constructor that receives a LuaState.     *     * @param L LuaState object associated with this JavaFunction object     */    public JavaFunction(LuaState L) {        mLuaStateCPoniter.set(L.getCPtrPeer());    }    /**     * Returns a parameter received from Lua. Parameters are numbered from 1.     * A reference to the JavaFunction itself is always the first parameter     * received (the same as &lt;code&gt;this&lt;/code&gt;).     *     * @param idx Index of the parameter.     * @return Reference to parameter.     * @see LuaObject     */    public LuaObject getParam(int idx) {        long luaStateCPoniter = mLuaStateCPoniter.get();        LuaState L = LuaStateFactory.getExistingState(luaStateCPoniter);        return L.getLuaObject(idx);    }    /**     * Register a JavaFunction with a given name. This method registers in a     * global variable the JavaFunction specified.     *     * @param name name of the function.     */    public void register(String name) throws LuaException {        long luaStateCPoniter = mLuaStateCPoniter.get();        //新增的方法，用于获取当前线程的LuaState        LuaState L = LuaStateFactory.getExistingState(luaStateCPoniter);        synchronized (L) {            L.pushJavaFunction(this);//在栈上生成一个userdata，并设置其metatable的一些方法            L.setGlobal(name);//然后将这个userdata存在global表上        }    }}</code></pre><ol start="5"><li>LuaStateFatcoty新增一个方法，根据当前的CPointer获取对应的LuaState。</li></ol><pre><code class="Java">    /**     * Returns a existing instance of LuaState     *     * @param cPointer     * @return LuaState     */    public synchronized static LuaState getExistingState(long cPointer) {        for(Object luaState:states){            if(luaState!=null){                LuaState lua_state = (LuaState)luaState;                if(lua_state.getCPtrPeer() == cPointer){                    return lua_state;                }            }        }        return null;    }</code></pre><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这种实现方式有点类似于协程，魔改之后算是基本能支持多线程操作，虽然不是很完美也可能不太稳定。这个多线程方案在产品中调用频次很低，所以也没有反馈实际效果如何，但是至少不崩溃并且异步回调是正常的。</p><p>因为Lua虚拟机本身就是只能单线程执行的，强行使其多线程执行肯定会有一些问题，除非有人有能力修改Lua的虚拟机那也是不错的。</p>]]></content>
    
    
    <categories>
      
      <category>游戏助手</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>LuaJava</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记Java内存回收</title>
    <link href="/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <url>/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>Java GC（Garbage Collection，GC），就是释放垃圾占用的内存空间，防止内存泄露。</p><p><img src="%E5%8F%AF%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE.jpg" srcset="/img/loading.gif" alt="可回收垃圾.jpg"></p><h1 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h1><p>判断内存对象是否能被回收主要有两种方法：</p><ul><li>引用计数法（Reachability Counting）</li><li>可达性分析算法（Reachability Analysis）</li></ul><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法是最简单的，在分配对象的时候，记录该对象当前的被引用次数 RC ，当有其他对象引用该对象的时候 RC 加1，解除引用的时候减1，当 RC 为0的时候就会被回收调。</p><pre><code class="java">// 字符串&quot;gc&quot;被s引用String s = new String(&quot;gc&quot;);//释放引用， 字符串&quot;gc&quot;被回收s = null;</code></pre><p>优点：</p><ol><li><p>可立即回收。每个对象都知道自己的引用计数，当变为0时可以立即回收，将自己接到空闲链表</p></li><li><p>GC暂停时间短。应用更新指针的时候就可以执行垃圾回收，开销分摊到整个生命周期，不需要挂起整个应用的运行直到堆中所有对象都处理结束（Stop-The-World）。</p></li></ol><p>缺点：</p><ol><li><p>计数器值的增减处理频繁。每次对象更新都需要对计数器进行增减，特别是被引用次数多的对象。</p></li><li><p>计数器需要占用很多位。计数器的值最大必须要能数完堆中所有对象的引用数。</p></li><li><p><strong>循环引用无法回收</strong>。</p></li></ol><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>可达性分析法解决了循环依赖的问题，基本思路是构建一系列的 GC 树，从根节点 GC Root 开始搜索，当对象不在任何一个 GC 树上的就属于可回收垃圾。</p><p><img src="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="可达性分析法.jpeg"></p><h3 id="GC-Root根节点的选择"><a href="#GC-Root根节点的选择" class="headerlink" title="GC Root根节点的选择"></a>GC Root根节点的选择</h3><p>在 Java 中，可作为 GC Root 的对象包括以下4种：</p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</p></li></ul><h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><p>确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收。</p><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><p>标记清除法最快最简单，直接回收被标记的垃圾。</p><p>缺点：</p><p>产生大量的内存碎片，内存利用率低。</p><p><img src="%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="标记清除法.jpeg"></p><h2 id="复制法"><a href="#复制法" class="headerlink" title="复制法"></a>复制法</h2><p>复制法将内存区域划分成两等分，每次只使用一份，回收垃圾的时候将存活的对象复制到另一边，然后清理掉这块内存。</p><p>优点：</p><p>速度快，避免内存碎片</p><p>缺点：</p><p>内存利用率不高，只能使用一半的内存</p><p><img src="%E5%A4%8D%E5%88%B6%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="复制法.jpeg"></p><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><p>标记清除法的升级版，在清除完标记的垃圾之后，存活的对象整理向一边移动，留出更大的内存区域。</p><p>优点：</p><p>避免内存碎片，内存利用率高</p><p>缺点：</p><p>内存变动频繁效率低速度慢</p><p><img src="%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="标记整理法.jpeg"></p><h2 id="分代回收法"><a href="#分代回收法" class="headerlink" title="分代回收法"></a>分代回收法</h2><p>分代回收算法综合了上面几种方法的优点，根据不同场景使用不同的方法。</p><p>该方法主要将内存分为新生代区和老年代区（Old），新生代区由Eden区和Survivor区组成，其中Survivor区又分为From和To区。</p><p><img src="%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="分代回收法.jpeg"></p><h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>大多数对象消亡速度都很快，所以大部分内存都在Eden区进行分配。</p><p>在Eden区进行的GC被称作（<strong>Minor GC</strong>），速度很快，每次Minor GC后基本会清空Eden区，剩余存活的对象会进入Survivor的From区，如果From区不够大会直接进入到Old区。</p><h3 id="Survivor区"><a href="#Survivor区" class="headerlink" title="Survivor区"></a>Survivor区</h3><p>Survivor区相当于Eden和Old的缓冲区，因为Eden 的 Minor GC 速度快，避免太多对象太快进入Old区。</p><p>每一次Minor GC ， Survivor 的 From 和 To 区就会进行<strong>复制回收</strong>，Survivor 中存活的对象年龄增加，直到达成年后（16岁或动态阈值）被送往Old区。</p><h3 id="Old区"><a href="#Old区" class="headerlink" title="Old区"></a>Old区</h3><p>Old区占用大部分内存空间，每次GC都会触发Stop-The-World，也叫 <strong>Major GC</strong> ，频率会比 Minor GC 要低。</p><p>因为Old区存活对象多，如果用复制法会操作很多次内存效率和空间利用率都低，所以在Old区折中使用<strong>标记整理法</strong>来进行回收。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://yq.aliyun.com/articles/708634" target="_blank" rel="noopener">咱们从头到尾说一次 Java 垃圾回收</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>内存</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LuaJava在Java、Android中的使用</title>
    <link href="/2017/10/08/LuaJava%E5%9C%A8Java%E3%80%81Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2017/10/08/LuaJava%E5%9C%A8Java%E3%80%81Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>最近公司在做一个项目，需要用Lua语言编写的脚本来动态控制安卓app的行为。  </p><p>项目涉及到Lua、LuaJava框架和安卓native开发等知识点。本文主要介绍Lua和Java语言之间是怎么相互调用的，并记录一些开发过程中碰到的问题。</p><h2 id="Lua一些概念"><a href="#Lua一些概念" class="headerlink" title="Lua一些概念"></a>Lua一些概念</h2><blockquote><p>Lua是一门扩展式程序设计语言，被设计成支持通用过程式编程，并有相关数据描述设施。同时对面向对象编程、函数式编程和数据驱动式编程也提供了良好的支持。 </p></blockquote><p>概念的东西简单看一下就行，总结来说Lua是一种轻量的语言，并且支持多重编程范式，可以任意地对语言进行自需的改造。</p><blockquote><p>作为一门扩展式语言，Lua没有”main”程序的概念：它只能嵌入一个宿主程序中工作，该宿主程序被称为被嵌入程序或者简称宿主。宿主程序可以调用函数执行一小段Lua代码，可以读写Lua变量，可以注册C函数让Lua代码调用。</p></blockquote><p>Lua程序一般不单独运行，虽然也可以但是能做的事情就比较简单。标准的<a href="https://www.lua.org/download.html" target="_blank" rel="noopener">Lua虚拟机</a>通过C语言编写的，一般是通过C\C++来拓展Lua的函数，这样接口兼容速度更快。  </p><p>这里重点记录一下Lua的栈，方便后面进行描述。</p><p>Lua虚拟机与C/C++之间的数据交换基本都是通过Lua构建虚拟<a href="https://cloudwu.github.io/lua53doc/manual.html#4.1" target="_blank" rel="noopener"><strong>栈</strong></a>来交互的，无论何时Lua调用 C，被调用的函数都得到一个新的栈， 这个栈独立于C函数本身的栈，也独立于之前的 Lua 栈。它里面包含了Lua传递给C函数的所有参数，而C函数则把要返回的结果放入这个栈以返回给调用者这里。</p><html><img src="Lua栈模型.png" srcset="/img/loading.gif" alt="Lua栈模型"/></html><p>如图Lua的栈的访问索引分为正索引和负索引。正的索引指的是栈上的绝对位置（从1开始）；负的索引则指从栈顶开始的偏移量。展开来说，如果堆栈有 n 个元素，那么索引 1 表示第一个元素（也就是最先被压栈的元素）而索引 n 则指最后一个元素；索引 -1 也是指最后一个元素（即栈顶的元素），索引 -n 是指第一个元素。</p><h2 id="用自定义C函数拓展Lua虚拟机"><a href="#用自定义C函数拓展Lua虚拟机" class="headerlink" title="用自定义C函数拓展Lua虚拟机"></a>用自定义C函数拓展Lua虚拟机</h2><p>自定义的C函数必须得符合Lua定义的方法签名：</p><pre><code>typedef int (*lua_CFunction) (lua_State *L)</code></pre><p>例如：</p><pre><code>int foo (lua_State *L) {    ...    // func body    ...};</code></pre><p>Lua虚拟机调用函数时，C函数通过Lua中的栈来接受参数，参数以正序入栈（第一个参数首先入栈），当需要向Lua返回值的时候，C函数只需要把它们以正序压到堆栈上（第一个返回值最先压入），然后返回这些返回值的个数。  </p><p>这么说还比较抽象还是具体举例子来说明，下面假设实现一个函数需要能够同时计算输入参数的平均值与和，然后将两个值返回给Lua层。</p><pre><code> int foo (lua_State *L) {       int n = lua_gettop(L);    /* 得到参数参数的个数 */       lua_Number sum = 0.0;       int i;       for (i = 1; i &lt;= n; i++) {             sum += lua_tonumber(L, i);       }       lua_pushnumber(L, sum/n);        /* 第一个返回值 */       lua_pushnumber(L, sum);         /* 第二个返回值 */       return 2;                   /* 返回值的个数 */     }</code></pre><p>其中</p><pre><code>int n = lua_gettop(L);    /* 得到参数参数的个数 */</code></pre><p>lua_gettop()函数可以得到栈顶元素的索引。因为索引是从1开始编号的,所以这个结果等于栈上的元素个数。特别指出，0表示栈为空。当然这里也可以调用</p><blockquote><p>lua_Number lua_tonumberx (lua_State <em>L, int index, int</em>isnum); 把给定索引处的 Lua 值转换为 lua_Number 这样一个 C 类型</p></blockquote><p>来直接得到指定索引的值。  </p><p>定义好c函数后，需要将其注册到Lua的虚拟机中才能被调用。</p><pre><code>lua_State *L = luaL_newstate();luaL_openlibs(L); //初始化一些自己的东西 // 传入任意的函数名和函数的指针作为参数lua_register(L, “foo&quot;, foo); // 加载运行Lua脚本luaL_dofile(L,&quot;test.lua&quot;);</code></pre><p>这里lua_register是一个宏定义，</p><pre><code>#define lua_register(L,n,f) \            (lua_pushcfunction(L, f), lua_setglobal(L, n))</code></pre><p>它的作用把 C 函数 f 设到全局变量 name 中，这样Lua就可以访问这个变量<a href="https://cloudwu.github.io/lua53doc/manual.html#2.4" target="_blank" rel="noopener"><strong>元表</strong></a>对应的call方法作为函数来调用。  </p><p>最后来写个测试demo来测试一下我们的自定义函数：</p><p><strong>test.lua:</strong></p><pre><code>function test()    ret1, ret2 = foo(1,2,3,4)    print ret1    print ret2endtest()</code></pre><p><strong>得到的结果为</strong>：</p><pre><code>&gt; 2.5&gt; 10</code></pre><p>So easy~</p><h2 id="Java与Lua之间的交互方式"><a href="#Java与Lua之间的交互方式" class="headerlink" title="Java与Lua之间的交互方式"></a>Java与Lua之间的交互方式</h2><p>基于上述Lua这种”寄生工作”的特性，Java与Lua语言之间相互调用的思路已经很明显了，就是以JNI作为中介。</p><p><strong>通过Native调用Lua：</strong></p><pre><code>graph TDJava--&gt;NativeNative--&gt;LuaVM</code></pre><p>以前的做法是先用C/C++借助JNI编写调用Java的接口函数，然后再将这些函数通过 <a href="https://github.com/LuaDist/toluapp" target="_blank" rel="noopener">tolua++</a>工具导出给Lua使用。这种做法最大的问题就是太繁琐，而且稍微有一点点修改，就要重新编译，严重降低了开发效率。  </p><p>这里我们可以借助一些框架，也就是Lua和Java之间的“桥梁”来省掉不必要的工作，例如：</p><ul><li><a href="http://www.luaj.org/luaj/3.0/README.html" target="_blank" rel="noopener">LuaJ</a></li><li><a href="https://github.com/jasonsantos/luajava" target="_blank" rel="noopener">LuaJava</a></li><li><a href="https://www.kahlua.com/" target="_blank" rel="noopener">kahlua</a>  </li></ul><p>还有不知名的mochalua，jill等就不贴出来了。  </p><p>首先LuaJ框架是使用纯Java语言来实现的，它用Java实现了一套自己的Lua虚拟机，所以就不需要JNI来做中介了，所以对于多年不接触C/C++代码的人来看会更加舒服一些。并且该框架还在更新维护，接口用起来更加方便，但是缺点在于纯Java实现，相对C语言实现<strong>速度慢</strong>。    </p><p>LuaJava框架就比上一个轻量一些，是基于Lua原生的虚拟机进行开发的，它只对标准的Lua编程API做了简单的JNI封装，Java层的代码也较少。这个框架虽然已经停止维护，但还是能支持最新的Lua5.3版本。  </p><p>我们开发的项目最后采用的是LuaJava框架，后文也将会对该框架进行解析。  </p><h2 id="用自定义Java函数拓展Lua虚拟机"><a href="#用自定义Java函数拓展Lua虚拟机" class="headerlink" title="用自定义Java函数拓展Lua虚拟机"></a>用自定义Java函数拓展Lua虚拟机</h2><p>LuaJava框架主要是对Lua的编程接口进行简单的封装，并且提供一些方便Lua、Java函数相互调用的接口，节省了自己去写JNI转换代码的功夫。后续会具体解析这个框架是怎么实现这部分的。</p><html><img src=".pngLuaJava框架的作用" srcset="/img/loading.gif" alt="LuaJava框架的作用" /></html>  <p>这里要使用自定义的Java函数来拓展Lua虚拟机需要以下几步：</p><ol><li>继承实现抽象类JavaFunction，实现自定义函数内容；</li><li>调用注册方法注册函数到虚拟机；</li><li>编写Lua脚本调用函数运行。  </li></ol><p>先看看JavaFunction类有什么方法，</p><html><img src="JavaFunction类图.png" srcset="/img/loading.gif" alt="JavaFunction类图" /></html><pre><code>L: Luastate</code></pre><p>Lua虚拟机的Java层访问接口，记录CLuaSate在C层的指针地址。</p><pre><code>excute(): int</code></pre><p>自定函数执行入口方法，这是一个需要自己实现的抽象方法，参数的获取和返回值的传递都在这里完成，其中返回的int型代表了返回给Lua结果的个数，与上面C方法是类似的。  </p><pre><code>getParam(index:int) : LuaObject</code></pre><p>获取Lua参数。在C层获取参数的index是从1开始的拿到函数的第一个参数，但是在这个LuaJava框架里你需要<strong>从2开始获得第一个参数</strong>，这是框架的一个小坑后面会讲到。  </p><p> LuaObject就是Lua对象在Java层的一个表示，实际上这个Object只维护了指向Lua注册表对应对象的一个引用，这里用到了<strong>Lua的引用机制</strong>的知识。  </p><blockquote><p>Lua 提供了一个 注册表， 这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。 这个表可以用有效伪索引 LUA_REGISTRYINDEX 来定位。 任何 C 库都可以在这张表里保存数据， 为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名， 或者取你自己 C 对象的地址，以轻量用户数据的形式做键， 还可以用你的代码创建出来的任意 Lua 对象做键。 关于变量名，字符串键名中以下划线加大写字母的名字被 Lua 保留。<br>注册表中的整数键用于引用机制（参见luaL_ref），以及一些预定义的值。因此，整数键不要用于别的目的。  </p></blockquote><pre><code>register(funcName : string) : void</code></pre><p>注册函数到Lua虚拟机。编写好具体Java类后只需要调用该父类方法，传入你的自定义函数名称就ok了！  </p><p>下面还是具体来讲个例子。这个自定义函数实现一个打印Log内容，最后返回一个boolean值的功能。</p><pre><code>Class TestLog extends JavaFunction{  …   @Override   public int execute() throws LuaException {        LuaObject paramObj = getParam(2); //获取Log参数        String logContent = paramObj.getString();//将C对象转换成Java对象        Log.d(&quot;[testLog]&quot;, logContent);        L.pushBoolean(true);//传递返回值        return 1;   }   …}</code></pre><p>编写好自定义函数之后，初始化LuaState，</p><pre><code>LuaState L = LuaStateFactory.newLuaState();L.openLibs();</code></pre><p>最后注册函数，编写我们的测试用例即可，</p><pre><code>/*注册函数，对应Lua函数名为testLog*/testFunc.register(“testLog“);/*载入并运行lua脚本文件*/L.LdoFile(“test.lua”);</code></pre><p>测试代码test.lua：</p><pre><code>require(&quot;os&quot;)function tlog(content)    testLog(content)endtlog(&quot;abc&quot;)tlog(&quot;time&quot;..os.time)</code></pre><p>得到期望的输出结果：</p><pre><code>&gt; abc&gt; 1494843227</code></pre><h2 id="LuaJava框架的工作原理"><a href="#LuaJava框架的工作原理" class="headerlink" title="LuaJava框架的工作原理"></a>LuaJava框架的工作原理</h2><p>上面说到我们需要调用注册方法register来注册自定义Java函数，查看其源码发现和C代码的实现是一样的，也是拆分成了两个步骤：</p><pre><code>public void register(String name ){        L.pushJavaFunction(this); // 先将函数对象压入栈        L.setGlobal(name); //将该对象设置为全局变量来使用     }</code></pre><p>第一步将Java对象压栈，Java部分没有什么代码，直接是调用了对应的native方法，jni_pushJavaFunction 来工作，看一下具体实现代码：</p><pre><code>void  jni_pushJavaFunction ( … ){    ...    ...   userData = ( jobject * ) lua_newuserdata( L , sizeof( jobject ) ); // 分配一块指定大小的内存块， 把内存块地址作为一个完全用户数据压栈   *userData = javaFunctionObjRef; // 用户空间存放一个指针即轻量用户数据   lua_newtable( L ); // 创建一个新表   lua_pushstring( L , LUACALLMETAMETHODTAG );     lua_pushcfunction( L , &amp;luaJavaFunctionCall ); // 将调用函数加入table中   lua_rawset( L , -3 );  // rawset 不会触发元方法避免调用到其他元操作   ...  if ( lua_setmetatable( L , -2 ) == 0 )   // 将该table作为userData的元表      {      ...   //抛出JNI异常    }</code></pre><p>首先创建一块Lua的Userdata数据类型，</p><pre><code>userData = ( jobject * ) lua_newuserdata( L , sizeof( jobject ) );</code></pre><p>这个userdata其实就是分配出一块jobject大小内存，用来记录对应的函数指针地址即通过JNI传来的javaFunctionObjRef，L是C层的LuaState指针。  </p><p>接下来需要创建该userdata的元表（metadata），还不清楚元表概念的返回去查手册看看就行，</p><pre><code>lua_pushstring( L , LUACALLMETAMETHODTAG );  lua_pushcfunction( L , &amp;luaJavaFunctionCall );</code></pre><p>这里将元表函数调用的常量标识LUACALLMETAMETHODTAG压入栈作为key，把一个叫做luaJavaFunctionCall函数的地址作为value，这样Lua以函数的方式调用这块userdata的时候就可以从元表查到这个函数地址并调用。  </p><p>最后回到Java层，</p><pre><code>L.setGlobal(name);</code></pre><p>将这一个userdata设置为一个全局变量，Lua脚本在运行时候就能正常操作这个变量了。</p><p>所以这个luaJavaFunctionCall函数就是自定义函数被Lua脚本调用到时，真正工作的地方，其实对应实现在C层：</p><pre><code>int  luaJavaFunctionCall( lua_State * L ){  ...  ... obj = lua_touserdata( L , 1 ); // 这个obj其实就是之前记录的函数引用地址 javaEnv = getEnvFromState( L ); //转换成userdata格式，从LuaState中读取出JNIEnv， ...  ret = ( *javaEnv )-&gt;CallIntMethod( javaEnv , *obj , java_function_method ); // 回调execute   ...   return ret;}</code></pre><p>看到这里在回去看看前面的JavaFunction.java类，就基本明白是怎么回事了。首先从函数栈中取出第一个参数（这里参考前面的自定义C函数部分），就是前面我们创建的userdata，是自定义JavaFunction类的指针，前面说到有一个坑点就在这里，JavaFUntion类的获取参数为什么要从index=2开始，</p><pre><code>getParam(index:int) : LuaObject</code></pre><p>因为第一个参数是我们的userdata本身，第二个开始才是正确的函数参数。<br>最后很简单了，通过jni反射调用Java层的execute方法（java_function_method）执行Java层的工作。<br>也是So easy！</p><p>到此完成一次完整的使用Java函数拓展Lua虚拟机的过程。这种方法和用C语言来拓展方式不太一样的地方，就是userdata和元表，获取参数的顺序也不太一样，再往深入的虚拟机里面的实现也还没来得及看，以后有时间的话再继续研究研究。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个Luajava框架其实坑点和问题其实还是很多的，并不能完善的上线，例如无法中断停止脚本、多线程问题和JavaGC超时异常等等问题也是头疼，但是经过本人的优化修改都已经把这些问题解决了~后续会继续写文记录一下。<br>One more，如果有能力和时间其实还是不建议使用这个框架了，太麻烦性能也不是特别好，自己从0搞一个。</p><p>这篇文章挖坑了好久，终于趁着放假填完了哈哈哈，之前这个新产品赶着上线事情太多了~</p>]]></content>
    
    
    <categories>
      
      <category>游戏助手</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>LUA</tag>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
