<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RePlugin使用自定义Activity坑位的实现方式</title>
    <link href="/2021/03/04/RePlugin%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Activity%E5%9D%91%E4%BD%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/03/04/RePlugin%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Activity%E5%9D%91%E4%BD%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>项目有需要让插件Activity的启动坑位声明带上showOnLockScreen，但是RePlugin默认实现所带的坑位只有常规按照透明主题或者launchMode来区分的，甚至不支持横屏activity坑位，Github上也有类似需要定制坑位的issue：</p><ul><li><p><a href="https://github.com/Qihoo360/RePlugin/issues/551" target="_blank" rel="noopener">怎么让Replugin启动一个插件Activity的时候，去使用我们在宿主AndroidManifest.xml中自定义的坑位？ #551</a></p></li><li><p><a href="https://github.com/Qihoo360/RePlugin/issues/740" target="_blank" rel="noopener">插件无法横屏，建议在repluginHostConfig中增加配置开关 #740</a></p></li></ul><p>但是RePlugin官方并没有提供接口或者解决方案，估计是缺少开发维护或者比较麻烦。</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>在尽量不修改源码的情况下去实现这个定制坑位的需求，避免引发其他新问题（项目时间有限）。</p><p>我们知道RePlugin启动插件Activity的方案：</p><ol><li>替换原启动Intent的component为宿主坑位；</li><li>在内存记录原intent的启动信息；</li><li>instrumentation反射创建activity的时候，通过RePluginClassLoader来查找对应的类，此时再将此坑位类对应的原intent信息取出，替换为插件的class。</li></ol><p>所以要实现自定义坑位，需要关注RePlugin内这三部分的具体实现。</p><p>第一部分是替换intent，RePlugin启动Activity分为两步，一是检查如果是插件component则分配坑位，二是调用context启动activity。所以重点是第一步手动分配intent的坑位，将component替换为（宿主context，坑位class），源intent的信息会记录到category字段中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">newIntent.addCategory(<span class="hljs-string">"container:"</span>+container);<span class="hljs-comment">//坑位class</span><br>newIntent.addCategory(<span class="hljs-string">"process:-2147483648"</span>);<span class="hljs-comment">//UI进程</span><br>newIntent.addCategory(<span class="hljs-string">"plugin:"</span>+PLUGIN_NAME);<span class="hljs-comment">//插件名称</span><br>newIntent.addCategory(<span class="hljs-string">"activity:"</span>+activityClass);<span class="hljs-comment">//原插件activityClass</span><br>newIntent.addCategory(<span class="hljs-string">"counter:0"</span>);<br></code></pre></td></tr></table></figure><p>第二部分记录原intent信息，记录的信息结体为PluginContainers#ActivityState，保存在PluginContainers.mStates中，这里需要保存一份自定坑位的启动记录。</p><p><strong>PluginContainers.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* 所有坑的状态集合<br>*/</span><br><span class="hljs-keyword">private</span> HashMap&lt;String, ActivityState&gt; mStates = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br></code></pre></td></tr></table></figure><p>第三部分反射创建Activity的时候调用路径为：RePluginClassLoader.loadClass -&gt; PMF.loadClass -&gt; PmBase.loadClass -&gt; PluginProcessPer.resolveActivityClass -&gt; PluginContainers.lookupByContainer，</p><p><strong>PmBase.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mContainerActivities.contains(className)) &#123;<br>     Class&lt;?&gt; c = mClient.resolveActivityClass(className);<br>     <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> c;<br>     &#125;<br>     ...<br>    <span class="hljs-keyword">return</span> DummyActivity<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中PmBase的mContainerActivities成员也维护着坑位信息，这里也需要加入自定的坑位信息。 </p><p>所以理论上只要修改上面这三部分，Activity自定坑位的启动链就没问题了。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>最后实现是一套简易的坑位分配系统，在Activity启动前分配坑位，反射创建Activity完成或超时还原坑位。</p><p><strong>主程序修改点</strong></p><ul><li>声明定制坑位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;activity<br> android:name=<span class="hljs-string">"ccontainer.showlock.translucent.HotNews"</span><br> android:configChanges=<span class="hljs-string">"keyboardHidden|orientation"</span><br> android:icon=<span class="hljs-string">"@drawable/wx"</span><br> android:label=<span class="hljs-string">"微信"</span><br> android:showOnLockScreen=<span class="hljs-string">"true"</span><br> android:showWhenLocked=<span class="hljs-string">"true"</span><br> android:theme=<span class="hljs-string">"@android:style/Theme.Translucent.NoTitleBar"</span> /&gt;<br></code></pre></td></tr></table></figure><ul><li>实现插件定制坑位分配的方法，在插件内反射调用：</li></ul><p><strong>RePluginContainerHook.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* 插件内反射调用<br>*/</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">loadPluginActivityContainer</span><span class="hljs-params">(String pluginName, String activityClass, Bundle extras)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sAvailableDefaultContainers.size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//分配可使用的坑位</span><br>    String container = sAvailableDefaultContainers.iterator().next();<br>    <span class="hljs-keyword">if</span> (container == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//构建自定义坑位的ActivityState</span><br>    PluginContainers.ActivityState activityState = <span class="hljs-keyword">new</span> PluginContainers.ActivityState(container);<br>    activityState.plugin = pluginName;<br>    activityState.activity = activityClass;<br><br>    <span class="hljs-keyword">boolean</span> success = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-comment">//添加到mStates</span><br>    HashMap&lt;String, PluginContainers.ActivityState&gt; stateHashMap = getRePluginContainerStates();<br>    <span class="hljs-keyword">if</span> (stateHashMap != <span class="hljs-keyword">null</span>) &#123;<br>        stateHashMap.put(container, activityState);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        success = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//添加到mContainerActivities</span><br>    HashSet&lt;String&gt; rePluginContainerActivities = getRePluginContainerActivities();<br>    <span class="hljs-keyword">if</span> (success &amp;&amp; rePluginContainerActivities != <span class="hljs-keyword">null</span>) &#123;<br>        rePluginContainerActivities.add(container);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        success = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (success) &#123;<br>        sAvailableDefaultContainers.remove(container);<br>        sUsedContainers.add(container);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (success) &#123;<br>        <span class="hljs-comment">//监听超时，回收未能正常启动的坑位</span><br>        Message timeoutMsg = sTimeoutHandler.obtainMessage(TimeoutHandler.MSG_TIMEOUT, container);<br>        sTimeoutHandler.sendMessageDelayed(timeoutMsg, TimeoutHandler.LAUNCH_TIMEOUT);<br>    &#125;<br>    <span class="hljs-keyword">return</span> success ? container : <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>继承RePluginClassLoader（在RePluginConfig创建时设置），自定义loadClass方法，增加还原坑位的调用时机和打底防崩溃的代码：</li></ul><p><strong>CustomRePluginLoader.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    Class&lt;?&gt; cl;<br>    <span class="hljs-keyword">try</span> &#123;<br>        cl = <span class="hljs-keyword">super</span>.loadClass(className, resolve);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;<br>        <span class="hljs-keyword">if</span> (RePluginContainerHook.isCustomContainer(className)) &#123;<br>            <span class="hljs-comment">//防止自定义坑位的逻辑出错，打底避免崩溃</span><br>            cl = DummyActivity<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> classNotFoundException;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        RePluginContainerHook.onPostLoadClass(className);<br>    &#125;<br>    <span class="hljs-keyword">return</span> cl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>RePluginContainerHook.java:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostLoadClass</span><span class="hljs-params">(String className)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sUsedContainers.remove(className)) &#123;<br>        sTimeoutHandler.removeMessages(TimeoutHandler.MSG_TIMEOUT, className);<br><br>        <span class="hljs-comment">//还原坑位</span><br>        sAvailableDefaultContainers.add(className);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>插件内修改点</strong></p><ul><li>反射调用分配定制坑位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* 构建新的intent，用于让插件在自定义坑位上启动<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Intent <span class="hljs-title">loadActivityCustomContainer</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>    ClassLoader hostClassLoader = RePlugin.getHostClassLoader();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Class classContainerHook = hostClassLoader.loadClass(<span class="hljs-string">"com.qihoo360.loader2.RePluginContainerHook"</span>);<br>        Method methodLoadPluginActivityContainer = classContainerHook.getDeclaredMethod(<span class="hljs-string">"loadPluginActivityContainer"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">String</span>.<span class="hljs-title">class</span>, <span class="hljs-title">Bundle</span>.<span class="hljs-title">class</span>)</span>;<br><br>        ComponentName componentName = intent.getComponent();<br>        String activityClass = componentName.getClassName();<br>        String container = (String) methodLoadPluginActivityContainer.invoke(<span class="hljs-keyword">null</span>, PLUGIN_NAME, activityClass, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (container == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Context hostContext = RePlugin.getHostContext();<br>        ComponentName newComponentName = <span class="hljs-keyword">new</span> ComponentName(hostContext, container);<br>        Intent newIntent = <span class="hljs-keyword">new</span> Intent(intent);<br>        newIntent.setComponent(newComponentName);<br>        newIntent.addCategory(<span class="hljs-string">"container:"</span> + container);<br>        newIntent.addCategory(<span class="hljs-string">"process:-2147483648"</span>);<br>        newIntent.addCategory(<span class="hljs-string">"plugin:"</span> + PLUGIN_NAME);<br>        newIntent.addCategory(<span class="hljs-string">"activity:"</span> + activityClass);<br>        newIntent.addCategory(<span class="hljs-string">"counter:0"</span>);<br>        <span class="hljs-keyword">return</span> newIntent;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p>不能同时启动太多activity，不然坑位不够用（毕竟简易版，可以增加坑位数量和回收机制解决）</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果能修改RePlugin源码应该有更优雅的实现方式，修改的地方差不多也就是上面提到的内容，但是时间比较紧急，后面能有更完善的实现再考虑提交PR。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>疑难杂症</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>RePlugin</tag>
      
      <tag>源码</tag>
      
      <tag>插件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存泄漏这个锅Glide不背——聊聊Glide到底把context怎么了</title>
    <link href="/2020/12/24/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%BF%99%E4%B8%AA%E9%94%85Glide%E4%B8%8D%E8%83%8C%E2%80%94%E2%80%94%E8%81%8A%E8%81%8AGlide%E5%88%B0%E5%BA%95%E6%8A%8Acontext%E6%80%8E%E4%B9%88%E4%BA%86/"/>
    <url>/2020/12/24/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%BF%99%E4%B8%AA%E9%94%85Glide%E4%B8%8D%E8%83%8C%E2%80%94%E2%80%94%E8%81%8A%E8%81%8AGlide%E5%88%B0%E5%BA%95%E6%8A%8Acontext%E6%80%8E%E4%B9%88%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天刷到一篇内容和观点都挺新颖的文章<a href="https://juejin.cn/post/6909362503898595342" target="_blank" rel="noopener">《小题大做 | Handler内存泄露全面分析》</a>，看到后面如何解决内存泄漏时有一段内容引起我的思考，</p><blockquote><p>“比如Glide使用的时候传的上下文不要用Activity而改用Application的上下文。”</p></blockquote><p>印象中这个说法中在很多其他文章都提到过，矛头都指向了“万恶的”Glide.with(context)，我想Glide这个量级的开源项目了，会犯这种低级错误吗，它到底拿这个context去干了什么？</p><h1 id="开扒源码"><a href="#开扒源码" class="headerlink" title="开扒源码"></a>开扒源码</h1><p>就拿Glide的Master代码来分析，快进到最危险的Glide.with(Activity activity)方法，传入参数activity，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestManager <span class="hljs-title">with</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> getRetriever(activity).get(activity);<br>&#125;<br></code></pre></td></tr></table></figure><p>getRetreiver方法是一个获取RequestManager的获取器，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RequestManagerRetriever <span class="hljs-title">getRetriever</span><span class="hljs-params">(@Nullable Context context)</span> </span>&#123;<br>             …<br>       <span class="hljs-keyword">return</span> Glide.get(context).getRequestManagerRetriever();<br>  &#125;<br></code></pre></td></tr></table></figure><p>传给Glide.get，初始化一个Glide的单例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Glide <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;<br>     GeneratedAppGlideModule annotationGeneratedModule =<br>         getAnnotationGeneratedGlideModules(context.getApplicationContext());<br>     <span class="hljs-keyword">synchronized</span> (Glide<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;<br>       <span class="hljs-keyword">if</span> (glide == <span class="hljs-keyword">null</span>) &#123;<br>         checkAndInitializeGlide(context, annotationGeneratedModule);<br>       &#125;<br>     &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> glide;<br> &#125;<br></code></pre></td></tr></table></figure><p>其中getAnnotationGeneratedGlideModules传入的是applicationContext，这里不存在activity泄漏，继续看getAnnotationGeneratedGlideModules-&gt;initializeGlide，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GlideContext glideContext;<br>…<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeGlide</span><span class="hljs-params">(<br>      @NonNull Context context,<br>      @NonNull GlideBuilder builder,<br>      @Nullable GeneratedAppGlideModule annotationGeneratedModule)</span> </span>&#123;<br>    Context applicationContext = context.getApplicationContext();<br>    ...<br></code></pre></td></tr></table></figure><p>可以看到第一行就是获取applicationContext，后面的代码都只使用了applicationContet，这个context被保存到GlideContext里，glideContext是单例Glide的成员，所以这里也排除了activity泄漏的可能。</p><p>回到开头，难道是RequestManagerRetriver.get(Activity)方法有问题？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (context == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"You cannot start a load on a null Context"</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="hljs-keyword">instanceof</span> Application)) &#123;<br>      <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;<br>        <span class="hljs-keyword">return</span> get((FragmentActivity) context);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> Activity) &#123;<br>        <span class="hljs-keyword">return</span> get((Activity) context);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> ContextWrapper<br>          <span class="hljs-comment">// Only unwrap a ContextWrapper if the baseContext has a non-null application context.</span><br>          <span class="hljs-comment">// Context#createPackageContext may return a Context without an Application instance,</span><br>          <span class="hljs-comment">// in which case a ContextWrapper may be used to attach one.</span><br>          &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> get(((ContextWrapper) context).getBaseContext());<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> getApplicationManager(context);<br>  &#125;<br></code></pre></td></tr></table></figure><p>跟进get((Activity) context)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestManager <span class="hljs-title">get</span><span class="hljs-params">(@NonNull Activity activity)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (Util.isOnBackgroundThread()) &#123;<br>     <span class="hljs-keyword">return</span> get(activity.getApplicationContext());<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (activity <span class="hljs-keyword">instanceof</span> FragmentActivity) &#123;<br>     <span class="hljs-keyword">return</span> get((FragmentActivity) activity);<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     assertNotDestroyed(activity);<br>     frameWaiter.registerSelf(activity);<br>     android.app.FragmentManager fm = activity.getFragmentManager();<br>     <span class="hljs-keyword">return</span> fragmentGet(activity, fm, <span class="hljs-comment">/*parentHint=*/</span> <span class="hljs-keyword">null</span>, isActivityVisible(activity));<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>第一个情况在后台线程getApplication没问题，其他分支就是通过Activity获取fragmentManager，Glide通过空白Fragment监听Activity生命周期来调度请求的方案，这里就不做细究了，我们只关心activity最后流向了哪里可能会导致泄漏的。</p><p>跟进所有分支，发现获取fragmentManager后，activity并没有被存储起来，除了有的会走到Glide的单例构造方法，但传入的也是applicationContext，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> RequestManager <span class="hljs-title">getApplicationManager</span><span class="hljs-params">(@NonNull Context context)</span> </span>&#123;<br>    <span class="hljs-comment">// Either an application context or we're on a background thread.</span><br>    <span class="hljs-keyword">if</span> (applicationManager == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>          ...<br>          Glide glide = Glide.get(context.getApplicationContext());<br>          applicationManager =<br>              factory.build(<br>                  glide,<br>                  <span class="hljs-keyword">new</span> ApplicationLifecycle(),<br>                  <span class="hljs-keyword">new</span> EmptyRequestManagerTreeNode(),<br>                  context.getApplicationContext());<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> applicationManager;<br>  &#125;<br></code></pre></td></tr></table></figure><h1 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h1><p>Glide拿context主要就两个事情：</p><ol><li>用applicationContext构造glideContext，获取上下文信息；</li><li>获取FragmentManager监听activity生命周期</li></ol><p>所以不管你在Glide.with(context)传入的是什么context，理论上都不会造成这个context的泄漏，除了FragmentManager可能存在bug，或是RequestManagerFragment出了bug导致内存问题，Glide本身的设计上是不存在大问题的。<del>毕竟是被这么多人使用久经考验的工具库。</del></p><p>当然也许旧版本的Glide可能存在泄漏的问题今天就不去考究了，至少目前最新release的版本，大家可以放心的给Glide传入activity！</p><h2 id="在RePlugin插件里使用Glide的一些问题"><a href="#在RePlugin插件里使用Glide的一些问题" class="headerlink" title="在RePlugin插件里使用Glide的一些问题"></a>在RePlugin插件里使用Glide的一些问题</h2><p>在<a href="https://github.com/Qihoo360/RePlugin" target="_blank" rel="noopener">RePlugin</a>框架的插件中使用Glide，传入哪个context还是要注意一下的。</p><p>Glide的placeholder在加载的时候，如果传入的是资源id，会去上文提到的glideContext里的context去加载drawable，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Drawable <span class="hljs-title">loadDrawable</span><span class="hljs-params">(@DrawableRes <span class="hljs-keyword">int</span> resourceId)</span> </span>&#123;<br>  Theme theme =<br>      requestOptions.getTheme() != <span class="hljs-keyword">null</span> ? requestOptions.getTheme() : context.getTheme();<br>  <span class="hljs-keyword">return</span> DrawableDecoderCompat.getDrawable(glideContext, resourceId, theme);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Glide是单例构造，如果在插件中第一次使用传入的context不是插件的context的话，会导致后续加载drawble的时候出现异常。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
      <tag>Glide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RePlugin框架在多线程场景下启动插件的问题</title>
    <link href="/2020/12/23/RePlugin%E6%A1%86%E6%9E%B6%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%90%AF%E5%8A%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/23/RePlugin%E6%A1%86%E6%9E%B6%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%90%AF%E5%8A%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="项目概况"><a href="#项目概况" class="headerlink" title="项目概况"></a>项目概况</h1><p>本项目使用了插件化框架RePlugin，不同于通常的Android插件化应用一个主程序拖带多个小的功能插件，项目主程序是一个空壳没有业务逻辑只负责启动一个大的主插件，同时也拖带其他小功能插件，结构如图所示：<br> <img src="%E6%8F%92%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%86%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="插件结构视图.jpg"></p><p>这样做的优点是可以最大限度的发挥插件化的灵活性，所有业务插件都能够快速的发版升级，不需要更新主程序。<br>缺点是加载速度更慢，需要加载完主插件APP才算可以正常使用，所以主插件需要控制包的大小和复杂度，并且加载成功率也是一个问题。</p><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>发版基本都是发插件没有升级主程序，最近放量升级了主程序版本后，发现主程序在升级安装后首次启动主插件失败概率大幅上升，在部分手机特别是7.0以下设备更为明显几乎是必现，而第二次再进入则正常。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>首先检查启动主插件的流程是否有问题，</p><p><img src="%E5%90%AF%E5%8A%A8%E4%B8%BB%E6%8F%92%E4%BB%B6%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt="启动主插件流程.jpg"></p><p>异步RePlugin.fetchContext目的是异步加载并且安装主插件，并运行起主插件的Application，不阻塞主线程做loading动画，异步加载完后再去post到主线程去启动主插件的activity。</p><p>根据打点情况来看是记录1异常增多，也就是RePlugin在加载fetchContext的时候失败了。</p><p>首先跟进fetchContext方法源码，看一下方法失败的分支，列举可能出现失败的场景。<br>跟到Plugin.loadLocked方法内开始产生失败结果主要6种情况：<br>1.框架初始化Loader类失败<br>2.插件信息加载失败<br>3.插件资源加载失败<br>4.插件dex释放失败<br>5.插件是否已经在内存<br>6.加载进程锁失败<br>通过观察log和断点调试，发现产生load false结果的主要是情况5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> il = mLoader.isAppLoaded();<br><span class="hljs-keyword">if</span>(LOG)&#123;<br>LogDebug.i(MAIN_TAG,<span class="hljs-string">"loadLocked():Initialized,isloaded="</span>+il);<br>&#125;<br><span class="hljs-keyword">return</span> il;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAppLoaded</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> mPlugin!=<span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法里面只判断了mPlugin是否已经加载到内存之中了，目的应该是避免重复的load插件。<br>继续观察日志，并没发现有其他加载失败的异常，可以认为插件是正常加载的为什么mPlugin会为null呢。</p><p>考虑到我们的项目有多个进程，进程之间不同插件通信也比较频繁，有一部分是通过RePlugin提供的fetchBinder的方法来通信的，fetchBinder方法也会尝试加载安装插件，而且我们主程序加载流程中也有异步操作，判断可能是出现了多线程同步问题。</p><p>继续查看代码，直到Plugin.loadLocked方法之前都没有看到任何的线程同步锁，进一步加深了同步问题的嫌疑，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">loadLocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> load, <span class="hljs-keyword">boolean</span> useCache)</span> </span>&#123;<br>        ...<br>        <span class="hljs-keyword">if</span> (mInitialized) &#123;<br>            ...<br>            <span class="hljs-keyword">boolean</span> il = mLoader.isAppLoaded();<br>            <span class="hljs-keyword">if</span> (LOG) &#123;<br>                LogDebug.i(MAIN_TAG, <span class="hljs-string">"loadLocked(): Initialized, is loaded = "</span> + il);<br>            &#125;<br>            <span class="hljs-keyword">return</span> il;<br>        &#125;<br>        mInitialized = <span class="hljs-keyword">true</span>;<br> <br>        ...<br> <br>        ProcessLocker lock = <span class="hljs-keyword">new</span> ProcessLocker(context, lockFileName);<br>        <span class="hljs-keyword">if</span> (LOG) &#123;<br>            LogDebug.i(PLUGIN_TAG, <span class="hljs-string">"loadLocked(): Ready to lock! logtag = "</span> + logTag + <span class="hljs-string">"; pn = "</span> + mInfo.getName());<br>        &#125;<br>        ...<br> <br>        <span class="hljs-keyword">long</span> t1 = System.currentTimeMillis();<br>        <span class="hljs-comment">//释放资源、加载dex和载入内存等操作，长耗时</span><br>        <span class="hljs-keyword">boolean</span> rc = doLoad(logTag, context, parent, manager, load);<br>        ...<br>        lock.unlock();<br> <br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>一直到 <strong>boolean rc = doload</strong> 方法开始使用了一个进程锁来释放和加载dex，方法完成后上面的mPlugin变量才会被赋值。</p><p>看到这里就比较明朗了，</p><p>关键因素是mInitialized这个变量，当一个线程A首先进入loadLocked方法，此时mInitialized=false，随后立即将mInitialized设置为true，这时候线程B也进入了这个方法，可能会读到mInitialized=true（说可能是因为这个字段没有volatile关键字，无法保证线程间的可见性），进入if分支后判断mLoader.isApploaded，这时候因为线程A还没有执行完doLoad方法，所以线程B直接返回了false插件加载失败。</p><p>调试发现在初始化的时候，确实有其他进程通过（RePlugin.fetchBinder方法）binder来加载这个插件，与我们在主程序中异步加载产生冲突。</p><p>因此我们在异步方法中使用RePlugin.fetchContext失败的概率大幅上升。</p><h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><p>RePlugin框架加载插件的方法是线程不安全的，后入的线程会接收到插件未加载的错误结果，插件加载时间过长（特别是插件升级），导致加载主插件的逻辑超时、超重试后自动结束，而当先入线程执行完毕，插件也正常加载完毕，所以第二次再进入的时候是正常的。</p><p>至于为什么是7.0和6.0设备高发，应该和Android版本或AOT没什么太大关系，除了AOT速度比较慢，设备速度慢就容易复现，这是一个通用的bug，取决于doload加载插件的耗时是否大于超时或重试次数。</p><p>复现条件：</p><ol><li>内置插件第一次安装或更新，且体积较大，导致loadLocked耗时过长；</li><li>多线程安装、调用未（正在）安装的插件；例如本例AsyncTask异步初始化和binder线程</li></ol><h1 id="修改方案"><a href="#修改方案" class="headerlink" title="修改方案"></a>修改方案</h1><p>暂不考虑修改RePlugin的代码，毕竟目前这种修改举轻若重，修改一点可能又会引发更多问题。</p><p>考虑修改我们的主插件加载流程，比较简单，异步等待插件真正加载完成后，回调函数内再启动主插件的Activity。</p><p>这里又有个小问题，RePlugin虽然提供了pluginInstalled的回调，但是仅限于外部插件而不是内置插件，所以没法得知内部插件的安装回调…</p><p><strong>方案B：在异步线程RePlugin.fetchContext之后，如果获取到context为null，则启动轮询检查dex是否释放完成，等待轮询结果后再走后面启动Activity的流程。</strong></p><p>鉴于框架本身也没有提供准确的回调时机，不是很完美，但也能提高加载的成功率，待后续发版验证。。。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>截至目前2020-11-27，RePlugin框架仍存在这些问题，有时间可以提几个PR。</p><ol><li>加载、启动插件线程安全</li><li>pluginInstalled接口只有调外部插件安装成功会回调</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>疑难杂症</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>RePlugin</tag>
      
      <tag>源码</tag>
      
      <tag>插件化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏助手-LuaJava框架实现脚本中断的方法</title>
    <link href="/2020/05/18/%E6%B8%B8%E6%88%8F%E5%8A%A9%E6%89%8B-LuaJava%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%96%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/05/18/%E6%B8%B8%E6%88%8F%E5%8A%A9%E6%89%8B-LuaJava%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E8%84%9A%E6%9C%AC%E4%B8%AD%E6%96%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>脚本有需求，需要实现一个forceStop方法供脚本主动中断。</p><p>在LuaJava框架中，Lua脚本从入口LuaState.pcall方法开始，会一直阻塞当前Java线程的运行，直到Lua脚本执行结束。</p><h1 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h1><p>实现中断退出使用的是Lua虚拟机的lua_error方法，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">LUA_API <span class="hljs-title">int</span>   <span class="hljs-params">(lua_error)</span> <span class="hljs-params">(lua_State *L)</span></span>;<br></code></pre></td></tr></table></figure><p>然后就是找到该方法的调用时机。</p><p>不能随便找个地方就直接使用lua_error来中断pcall，这样会导致Java层出现各种莫名其妙的异常使得整个程序崩溃。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>选择在luajava.cpp的luaJavaFunctionCall方法中修改，所有通过框架注册的自定义Java函数都会走到这里，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">luaJavaFunctionCall</span><span class="hljs-params">(lua_State *L)</span> </span>&#123;<br>  ...<br>   <span class="hljs-comment">/* the Object must be an instance of the JavaFunction class */</span><br>    <span class="hljs-keyword">if</span> (javaEnv-&gt;IsInstanceOf(*obj, java_function_class) ==<br>        JNI_FALSE) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Called Java object is not a JavaFunction\n"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    ret = javaEnv-&gt;CallIntMethod(*obj, java_function_method,(jlong)L);<br>    javaEnv-&gt;CallVoidMethod(*obj, java_function_method_cleanup);<br>  ...<br>   checkLuaStop(L);<br>&#125;<br></code></pre></td></tr></table></figure><p>在方法末尾增加个检查退出函数 checkLuaStop(LuaState* L)，通过全局标识位forceStop来判断是否需要退出，顺便给Lua脚本一个结束回调，最后才抛出lua_error结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">FUNC_EXPORT <span class="hljs-keyword">void</span> <span class="hljs-title">checkLuaStop</span><span class="hljs-params">(lua_State *L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (forceStop == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">/*在用户主动终止脚本运行之前执行的回调函数 */</span><br>        LOGE(<span class="hljs-string">"beforeUserExit"</span>);<br>        lua_getglobal(L, <span class="hljs-string">"beforeUserExit"</span>);<br>        lua_call(L, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        lua_pop(L, <span class="hljs-number">1</span>);<br><br>        lua_pushstring(L, <span class="hljs-string">"lua force close!"</span>);<br>        lua_error(L);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>forceStop的值由自定义注册的forceStop函数控制的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">jni_forceStop</span><span class="hljs-params">(JNIEnv *env, jobject jobj, jobject cptr)</span> </span>&#123;<br>    forceStop = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function">jboolean <span class="hljs-title">jni_isClosing</span><span class="hljs-params">(JNIEnv *env, jobject jobj, jobject cptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (forceStop == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> JNI_TRUE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> JNI_FALSE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>游戏助手</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>LuaJava</tag>
      
      <tag>脚本</tag>
      
      <tag>Lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析Android SparseArray</title>
    <link href="/2020/05/08/%E6%B5%85%E6%9E%90Android%20SparseArray/"/>
    <url>/2020/05/08/%E6%B5%85%E6%9E%90Android%20SparseArray/</url>
    
    <content type="html"><![CDATA[<h1 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h1><ul><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/util/SparseArray.java" target="_blank" rel="noopener">源码路径：frameworks/base/core/java/android/util/SparseArray.java</a></li></ul><p>SparseArray 可以替代 HashMap&lt;Integer,Object&gt; 使用，在数据量不大的情况下，虽然查询效率达不到 O(1)，但 SparseArray 能节约更多内存，在移动端上更加适用。</p><p>简单来说 HashMap 的实现是用空间换时间，而 SparseArray 是用时间换空间。</p><p>SparseArray 主要技术点：</p><ul><li><p>使用原始 int 作为 key，避免自动装箱</p></li><li><p>使用二分查找定位 key</p></li><li><p>延迟删除、复用 delete 项</p></li></ul><h1 id="主要成员变量"><a href="#主要成员变量" class="headerlink" title="主要成员变量"></a>主要成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SparseArray</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object DELETED = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mGarbage = <span class="hljs-keyword">false</span>; <span class="hljs-comment">//标记是否存在待回收的键值对</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] mKeys;<br>    <span class="hljs-keyword">private</span> Object[] mValues;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mSize;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="SparseArray.jpg" srcset="/img/loading.gif" alt="SparseArray.jpg"></p><p>从结构上看比 HashMap 简单了很多，占用的内存也更少了。</p><h1 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h1><p>先看一下比较有特色的 GC 流程，SparseArray 的 GC 用的是”<a href="https://hoholidayx.github.io/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E6%B3%95">标记整理</a>“算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gc</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> n = mSize;<br>       <span class="hljs-keyword">int</span> o = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span>[] keys = mKeys;<br>       Object[] values = mValues;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>           Object val = values[i];<br>           <span class="hljs-keyword">if</span> (val != DELETED) &#123;<br>           <span class="hljs-comment">// 将存活的 item 移动到小端</span><br>               <span class="hljs-keyword">if</span> (i != o) &#123;<br>                   keys[o] = keys[i];<br>                   values[o] = val;<br>                   values[i] = <span class="hljs-keyword">null</span>;<br>               &#125;<br>               o++;<br>           &#125;<br>       &#125;<br>       mGarbage = <span class="hljs-keyword">false</span>;<br>       mSize = o;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="put"><a href="#put" class="headerlink" title="put"></a>put</h1><p>在看 put 之前补一下按位取反的知识，就比较好理解代码为什么这么处理了。</p><blockquote><p>所有正整数的按位取反是其本身+1的负数，所有负整数的按位取反是其本身+1的绝对值，零的按位取反是 -1</p></blockquote><p>put 方法流程：</p><ol><li><p>二分查找 key，找到返回正数，否则返回左指针的负值（ ~ 按位取反后就是要插入的位置）；</p></li><li><p>如果存在则更新数值，返回；</p></li><li><p>如果对应位置被标记为 DELETED ，复用，返回；</p></li><li><p>如需要 GC ，GC 后重新查找插入位置；</p></li><li><p>插入数据，如果 mSize 不够则乘 2 扩容复制；</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E value)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>     <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>         mValues[i] = value;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         i = ~i;<br><br>         <span class="hljs-keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;<br>             mKeys[i] = key;<br>             mValues[i] = value;<br>             <span class="hljs-keyword">return</span>;<br>         &#125;<br><br>         <span class="hljs-keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;<br>             gc();<br><br>             <span class="hljs-comment">// Search again because indices may have changed.</span><br>             i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);<br>         &#125;<br><br>         mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);<br>         mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);<br>         mSize++;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="insert-与扩容"><a href="#insert-与扩容" class="headerlink" title="insert 与扩容"></a>insert 与扩容</h1><p>数组的插入和扩容的具体实现在 GrowingArrayUtils 里，</p><p>当前容量足够，腾出位置直接插入；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (currentSize + <span class="hljs-number">1</span> &lt;= array.length) &#123;<br>    <span class="hljs-comment">//将 index 之后的数据往后移动</span><br>    System.arraycopy(array, index, array, index + <span class="hljs-number">1</span>, currentSize - index);<br>    array[index] = element;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><p>容量不够，先乘以 2 扩容后再腾出位置直接插入；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// growSize 乘 2</span><br>T[] newArray = ArrayUtils.newUnpaddedArray((Class&lt;T&gt;)array.getClass().getComponentType(), growSize(currentSize));<br><span class="hljs-comment">// 复制数据到新扩容的数组上</span><br>System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, index);<br>newArray[index] = element;<br><span class="hljs-comment">//将 index 之后的数据往后移动</span><br>System.arraycopy(array, index, newArray, index + <span class="hljs-number">1</span>, array.length - index);<br><span class="hljs-keyword">return</span> newArray;<br></code></pre></td></tr></table></figure><h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><p>删除的方法比较简单，找到对应 key 的 index，标记为 DELETED 状态，设置垃圾回收状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>       <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">if</span> (mValues[i] != DELETED) &#123;<br>               mValues[i] = DELETED;<br>               mGarbage = <span class="hljs-keyword">true</span>;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SparseArray 的代码实现比较简单，延迟删除复用的特点使其适合于<strong>数据量小、重复使用、快速读写的场景</strong>。</p><p>缺点：</p><ul><li><p>性能受限于二分查找</p></li><li><p>数组占用连续内存空间；</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android10启动Activity流程</title>
    <link href="/2020/05/03/Android10%E5%90%AF%E5%8A%A8Activity%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/05/03/Android10%E5%90%AF%E5%8A%A8Activity%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>从 Android2.3 到 Android10 ，Activity 的启动的基本流程并没有什么大变化，只是多了更多的封装、优化和新功能。</p><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="%E5%9F%BA%E4%BA%8EAndroid10Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="基于Android10Activity的启动流程.png"></p><h1 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h1><ul><li>ActivityThread  应用的主线程入口；</li><li>ActivityManagerService(AMS)  负责管理 activity、task 和 process，管理主入口；</li><li>ActivityStarter  负责 Activity 的启动模式，启动Flag相关处理；</li><li>ActivityStack  负责 Activity 栈和对应状态，并启动对应生命周期；</li><li>ActivityStackSupervisor  与ActivityStack类似，与 WindowManagerService 有交互；</li><li>ClientTransactionItem  执行具体activity生命周期的抽象类，子类  LaunchActivityItem 等</li><li>ClientTransaction  处理相关的信息和生命周期状态</li><li>TransactionExecutor 主要作用是执行ClientTransaction</li><li>ClientLifecycleManager 生命周期的管理调用</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>通过 ContextImpl 或者 shell am start 等入口，向 AMS 发送启动 Activity 请求；</p></li><li><p>AMS 启动工作的前半部分工作，一是根据启动模式和启动标志，找到或创建 ActivityRecord 以及对应的 TaskRecord；二是暂停当前显示的 Activity（onPause），然后处理 新 Activity 启动流程和应用的切换工作；</p></li><li><p>AMS 后半部分工作，通知 zygote 创建并初始化新目标进程（新启动 app 的情况），目标进程 ActivityThread 初始化后通知 AMS 绑定当前进程 ProcessRecord到 ActivityRecord 和 TaskRecord，AMS 调用 realStartActivity 真正启动 Activity（走生命周期） ;</p></li><li><p>目标进程新 Activity 启动完成，在 IdleHandler 发送通知给 AMS，AMS 负责停止之前的 Activity（onStop）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android系统启动之二-启动SystemServer</title>
    <link href="/2020/04/29/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%BA%8C-%E5%90%AF%E5%8A%A8SystemServer/"/>
    <url>/2020/04/29/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%BA%8C-%E5%90%AF%E5%8A%A8SystemServer/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继上篇<a href="https://hoholidayx.github.io/2020/04/28/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%80-%E5%90%AF%E5%8A%A8Zygote/">《Android系统启动之一-启动Zygote》</a>，本篇继续来看 SystemServer 进程做了什么事情。</p><p>Zygote 和 SystemServer 是 Android 系统最重要的两个进程，Zygote 负责创建新进程，而 SystemServer 负责创建应用所需要的服务，例如 ActivityManagerService。</p><p><img src="logo.jpeg" srcset="/img/loading.gif" alt="logo.jpeg"></p><h1 id="SystemServer-main"><a href="#SystemServer-main" class="headerlink" title="SystemServer.main"></a>SystemServer.main</h1><p>源码：<a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/services/java/com/android/server/SystemServer.java;l=349" target="_blank" rel="noopener">frameworks/base/services/java/com/android/server/SystemServer.java</a></p><p>main 方法没有什么内容，就是 new 了一个 SystemServer 类之后调用它的 run 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * The main entry point from zygote.<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> SystemServer().run();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SystemServer-run"><a href="#SystemServer-run" class="headerlink" title="SystemServer.run"></a>SystemServer.run</h1><p>run 方法的主要工作：</p><ol><li><p>初始化自身和环境；</p></li><li><p>加载 android_server native 库；</p></li><li><p>创建 SystemContext 和 SystemServiceManager；</p></li><li><p>启动各类 Service；</p></li><li><p>Looper 当前线程，开始接收消息。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br> ...<br> <span class="hljs-comment">//取消 Java 虚拟机的内存限制，</span><br> VMRuntime.getRuntime().clearGrowthLimit();<br>   ...<br> <span class="hljs-comment">// Increase the number of binder threads in system_server</span><br> BinderInternal.setMaxThreads(sMaxBinderThreads);<br>   ...<br>  <span class="hljs-comment">// Prepare the main looper thread (this thread).</span><br>  <span class="hljs-comment">//准备 Looper</span><br>  android.os.Process.setThreadPriority(<br>          android.os.Process.THREAD_PRIORITY_FOREGROUND);<br>  android.os.Process.setCanSelfBackground(<span class="hljs-keyword">false</span>);<br>  Looper.prepareMainLooper();<br>  ...<br>   <span class="hljs-comment">//创建系统 context</span><br>   createSystemContext();<br><br>   <span class="hljs-comment">// Create the system service manager.</span><br>   mSystemServiceManager = <span class="hljs-keyword">new</span> SystemServiceManager(mSystemContext);<br>   mSystemServiceManager.setStartInfo(mRuntimeRestart,<br>           mRuntimeStartElapsedTime, mRuntimeStartUptime);<br>   LocalServices.addService(SystemServiceManager<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">mSystemServiceManager</span>)</span>;<br>   ...<br><br>    <span class="hljs-comment">// Start services.</span><br>   <span class="hljs-comment">//启动各项服务</span><br>   startBootstrapServices();<br>   startCoreServices();<br>   startOtherServices();<br>   ...<br>   <span class="hljs-comment">//开始 Looper</span><br>   Looper.loop();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="createSystemContext"><a href="#createSystemContext" class="headerlink" title="createSystemContext"></a>createSystemContext</h2><p>关于如何创建系统 context 流程比较长，借用一图（来源：<a href="http://gityuan.com/" target="_blank" rel="noopener">gityuan</a>）来看比较清晰。</p><p><img src="SystemServer%E5%88%9B%E5%BB%BASystemContext%E6%B5%81%E7%A8%8B.webp" srcset="/img/loading.gif" alt="SystemServer创建SystemContext流程.webp"></p><h2 id="startBootstrapServices"><a href="#startBootstrapServices" class="headerlink" title="startBootstrapServices"></a>startBootstrapServices</h2><p>该函数负责启动一些关键性的系统服务，以便 Android 系统能开始第一步正常运行。例如安装服务、屏幕显示服务等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startBootstrapServices</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//启动 WatchDog</span><br> <span class="hljs-keyword">final</span> Watchdog watchdog = Watchdog.getInstance();<br>     watchdog.start();<br>       ...<br>   <span class="hljs-comment">//启动安装服务</span><br>   Installer installer = mSystemServiceManager.startService(Installer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>   ...<br>   <span class="hljs-comment">//启动亮屏服务</span><br>   mSystemServiceManager.startService(LightsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="startCoreServices"><a href="#startCoreServices" class="headerlink" title="startCoreServices"></a>startCoreServices</h2><p>这个函数启动一些重要的服务，但是不会影响到 Android 系统正常的启动。例如电池服务、用量统计服务等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startCoreServices</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 电池服务</span><br>mSystemServiceManager.startService(BatteryService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>...<br><span class="hljs-comment">//用量统计服务</span><br>mSystemServiceManager.startService(UsageStatsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>mActivityManagerService.setUsageStatsManager(<br>        LocalServices.getService(UsageStatsManagerInternal<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;<br>...<br><span class="hljs-comment">//设备缓存服务</span><br>mSystemServiceManager.startService(CachedDeviceStateService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="startOtherServices"><a href="#startOtherServices" class="headerlink" title="startOtherServices"></a>startOtherServices</h2><p>启动其他服务，例如 WindowManagerService、InputManagerService 和 NetworkManagementService 等。</p><p>最后最重要的是 AMS 的 systemReady 方法，调用这个方法表示 SystemServer 已经准备好其他服务了，等待 AMS 做最后的状态准备，AMS 回调完成后表示 AMS 可以开始接受启动其他应用程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startOtherServices</span><span class="hljs-params">()</span> </span>&#123;<br>  ...<br>  <span class="hljs-comment">// We now tell the activity manager it is okay to run third party</span><br>  <span class="hljs-comment">// code.  It will call back into us once it has gotten to the state</span><br>  <span class="hljs-comment">// where third party code can really run (but before it has actually</span><br>  <span class="hljs-comment">// started launching the initial applications), for us to complete our</span><br>  <span class="hljs-comment">// initialization.</span><br>  mActivityManagerService.systemReady(() -&gt; &#123;<br>  ...<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动Looper"><a href="#启动Looper" class="headerlink" title="启动Looper"></a>启动Looper</h2><p>最后，Looper.loop() 进入等待状态，SystemServer 启动完成，等待其他线程发送消息再进行下一步动作。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
      <tag>SystemServer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android系统启动之一-启动Zygote</title>
    <link href="/2020/04/28/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%80-%E5%90%AF%E5%8A%A8Zygote/"/>
    <url>/2020/04/28/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B9%8B%E4%B8%80-%E5%90%AF%E5%8A%A8Zygote/</url>
    
    <content type="html"><![CDATA[<h1 id="Zygote-是什么"><a href="#Zygote-是什么" class="headerlink" title="Zygote 是什么"></a>Zygote 是什么</h1><p>Zygote 中文翻译受精卵，顾名思义是细胞分裂的起点。</p><p>在 Android 系统中，通常每个应用程序都运行在单独的进程中，每个进程有自己的 Java 虚拟机，而进程和虚拟机就是由 Zygote 创建孵化出来的。</p><p>由下图的 Activity 启动栈可以看出，Zygote 就是 Java 堆栈的起点。</p><p><img src="Zygote%E6%98%AF%E4%BB%80%E4%B9%88.png" srcset="/img/loading.gif" alt="Zygote是什么.png"></p><h1 id="Zygote-的作用"><a href="#Zygote-的作用" class="headerlink" title="Zygote 的作用"></a>Zygote 的作用</h1><ul><li><p>启动 Java 虚拟机；</p></li><li><p>加载常用类、JNI 函数、主题资源、共享库；</p></li><li><p>创建应用进程；</p></li><li><p>启动 <strong>SystemServer</strong></p></li></ul><h1 id="创建-Zygote"><a href="#创建-Zygote" class="headerlink" title="创建 Zygote"></a>创建 Zygote</h1><h2 id="init-进程"><a href="#init-进程" class="headerlink" title="init 进程"></a>init 进程</h2><p>Linux 系统在启动的时候，会创建一个 init 进程，进程会读取 init.rc 配置文件运行一些初始化脚本，类似于在 Windows 下的开始-&gt;启动菜单。</p><p><img src="init.rc.png" srcset="/img/loading.gif" alt="init.rc.png"></p><p><em>这里需要使用 Android 模拟器或者可以 root 的手机获取 root 权限才能看到。</em></p><p>还有一个 init.zygote32.rc 文件（64 位就是 init.zygote64_32.rc），是 zygote 的启动脚本，会被 init.rc 调用。</p><p><strong>/init.rc</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>import /init.usb.rc<br>import /init.$&#123;ro.hardware&#125;.rc<br>import /vendor/etc/init/hw/init.$&#123;ro.hardware&#125;.rc<br>import /init.usb.configfs.rc<br>import /init.$&#123;ro.zygote&#125;.rc<br><br>...<br><span class="hljs-meta"><br>#</span><span class="bash"> to start-zygote <span class="hljs-keyword">in</span> device<span class="hljs-string">'s init.rc to unblock zygote start.</span></span><br>on zygote-start &amp;&amp; property:ro.crypto.state=unencrypted<br>    # A/B update verifier that marks a successful boot.<br>    exec_start update_verifier_nonencrypted<br>    start netd<br>    start zygote<br>    start zygote_secondary<br><br>...<br></code></pre></td></tr></table></figure><p><strong>/init.zygote32.rc</strong></p><p>真正启动 zygote 的是一个 /system/bin/app_process 程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server<br>    class main<br>    priority -20<br>    user root<br>    group root readproc reserved_disk<br>    socket zygote stream 660 root system<br>    onrestart write /sys/android_power/request_state wake<br>    onrestart write /sys/power/state on<br>    onrestart restart audioserver<br>    onrestart restart cameraserver<br>    onrestart restart media<br>    onrestart restart netd<br>    onrestart restart wificond<br>    writepid /dev/cpuset/foreground/tasks<br></code></pre></td></tr></table></figure><h2 id="app-process"><a href="#app-process" class="headerlink" title="app_process"></a>app_process</h2><p>app_process的源码在 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/cmds/app_process/app_main.cpp;bpv=0;bpt=1" target="_blank" rel="noopener">frameworks/base/cmds/app_process/app_main.cpp</a>。</p><p>C++ 应用程序，直接找 main 入口，这里主要做了 3 件事：</p><ol><li>创建 AndroidRuntime 类；</li><li>输入参数给 runtime；</li><li>修改进程名为 zygote</li><li>启动 runtime 的 start 方法。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> argv[])</span><br></span>&#123;<br>  ...<br>  <span class="hljs-comment">//创建 AppRuntime 类，继承于 AndroidRuntime，重写做一些回调</span><br>  <span class="hljs-function">AppRuntime <span class="hljs-title">runtime</span><span class="hljs-params">(argv[<span class="hljs-number">0</span>], computeArgBlockSize(argc, argv))</span></span>;<br>  ...<br>  <span class="hljs-comment">//解析输入参数</span><br>  ...<br>  <span class="hljs-keyword">if</span> (!niceName.isEmpty()) &#123;<br>      <span class="hljs-comment">//进程名设置为zygote</span><br>      runtime.setArgv0(niceName.<span class="hljs-built_in">string</span>(), <span class="hljs-literal">true</span> <span class="hljs-comment">/* setProcName */</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (zygote) &#123;<br>      <span class="hljs-comment">// 作为 zygote 进程启动的，走这个分支</span><br>      runtime.start(<span class="hljs-string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (className) &#123;<br><span class="hljs-comment">// 非 zygote 模式启动</span><br>      runtime.start(<span class="hljs-string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      ...<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="AndroidRuntime-cpp"><a href="#AndroidRuntime-cpp" class="headerlink" title="AndroidRuntime.cpp"></a>AndroidRuntime.cpp</h2><p>源码： <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/jni/AndroidRuntime.cpp;l=1120;bpv=0;bpt=1" target="_blank" rel="noopener">frameworks/base/core/jni/AndroidRuntime.cpp</a></p><p>在 start 方法里主要做了几件事：</p><ol><li>启动 Java 虚拟机；</li><li>注册相关 Android Native 函数；</li><li>启动 Java main 主线程。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*<br> * Start the Android runtime.  This involves starting the virtual machine<br> * and calling the "static void main(String[] args)" method in the class<br> * named by "className".<br> *<br> * Passes the main function two arguments, the class name and the specified<br> * options string.<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AndroidRuntime::start</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* className, <span class="hljs-keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="hljs-keyword">bool</span> zygote)</span><br></span>&#123;<br>...<br><br>    <span class="hljs-comment">/* start the virtual machine */</span><br>    JniInvocation jni_invocation;<br>    jni_invocation.Init(<span class="hljs-literal">NULL</span>);<br>    JNIEnv* env;<br>    <span class="hljs-comment">//启动 Java 虚拟机</span><br>    <span class="hljs-keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    onVmCreated(env);<br><br>    ...<br><br>    <span class="hljs-comment">/*<br>     * 注册相关 Android Native 函数<br>     * Register android functions.<br>     */</span><br>    <span class="hljs-keyword">if</span> (startReg(env) &lt; <span class="hljs-number">0</span>) &#123;<br>        ALOGE(<span class="hljs-string">"Unable to register all android natives\n"</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-comment">/*<br>     * 反射调用 ZygoteInit/RuntimeInit 的 main 方法，会在虚拟机里创建一个无限循环的主线程<br>     *<br>     * Start VM.  This thread becomes the main thread of the VM, and will<br>     * not return until the VM exits.<br>     */</span><br>    <span class="hljs-keyword">char</span>* slashClassName = toSlashClassName(className != <span class="hljs-literal">NULL</span> ? className : <span class="hljs-string">""</span>);<br>    jclass startClass = env-&gt;FindClass(slashClassName);<br>    <span class="hljs-keyword">if</span> (startClass == <span class="hljs-literal">NULL</span>) &#123;<br>        ALOGE(<span class="hljs-string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);<br>        <span class="hljs-comment">/* keep going */</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="hljs-string">"main"</span>,<br>            <span class="hljs-string">"([Ljava/lang/String;)V"</span>);<br>        <span class="hljs-keyword">if</span> (startMeth == <span class="hljs-literal">NULL</span>) &#123;<br>            ALOGE(<span class="hljs-string">"JavaVM unable to find main() in '%s'\n"</span>, className);<br>            <span class="hljs-comment">/* keep going */</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(slashClassName);<br><br>    ALOGD(<span class="hljs-string">"Shutting down VM\n"</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)<br>        ALOGW(<span class="hljs-string">"Warning: unable to detach main thread\n"</span>);<br>    <span class="hljs-keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="hljs-number">0</span>)<br>        ALOGW(<span class="hljs-string">"Warning: VM did not shut down cleanly\n"</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用完 ZygoteInit 类的 main 函数后，就开始交由 Java 端来构建 Android 的运行环境了。</p><h1 id="Zygote-的初始化"><a href="#Zygote-的初始化" class="headerlink" title="Zygote 的初始化"></a>Zygote 的初始化</h1><h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main"></a>ZygoteInit.main</h2><p>源码： <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/ZygoteInit.java;l=816;bpv=0;bpt=1" target="_blank" rel="noopener">frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</a></p><p>在 ZygoteInit 入口 main 函数，主要工作：</p><ol><li>预加载资源和类；</li><li>fork创建 SystemServer 进程（第一次启动）；</li><li>在 zygote 进程开启 socket 监听，等待接收 SystemServer 的远程调用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * This is the entry point for a Zygote process.  It creates the Zygote server, loads resources,<br> * and handles other tasks related to preparing the process for forking into applications.<br> * ...<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String argv[])</span> </span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br> ZygoteServer zygoteServer = <span class="hljs-keyword">null</span>;<br> ...<br> Runnable caller;<br> ...<br> <span class="hljs-keyword">if</span> (!enableLazyPreload) &#123;<br>        <span class="hljs-comment">//预加载一些资源和类</span><br>        preload(bootTimingsTraceLog);<br>     &#125;<br>     ...<br>     zygoteServer = <span class="hljs-keyword">new</span> ZygoteServer(isPrimaryZygote);<br>     <span class="hljs-keyword">if</span> (startSystemServer) &#123;<br><br>     <span class="hljs-comment">// 第一次启动，创建系统 SystemServer 进程</span><br>         Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);<br><br>         <span class="hljs-comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span><br>         <span class="hljs-comment">// child (system_server) process.</span><br>         <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>             r.run();<br>             <span class="hljs-keyword">return</span>;<br>         &#125;<br>     &#125;<br><br>     Log.i(TAG, <span class="hljs-string">"Accepting command socket connections"</span>);<br><br>     <span class="hljs-comment">// The select loop returns early in the child process after a fork and</span><br>     <span class="hljs-comment">// loops forever in the zygote.</span><br>     <span class="hljs-comment">// 开启循环监听 Socket 消息</span><br>     aller = zygoteServer.runSelectLoop(abiList);<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    Log.e(TAG, <span class="hljs-string">"System zygote died with exception"</span>, ex);<br>    <span class="hljs-keyword">throw</span> ex;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (zygoteServer != <span class="hljs-keyword">null</span>) &#123;<br>        zygoteServer.closeServerSocket();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// We're in the child process and have exited the select loop. Proceed to execute the</span><br><span class="hljs-comment">// command.</span><br><span class="hljs-keyword">if</span> (caller != <span class="hljs-keyword">null</span>) &#123;<br>    caller.run();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ZygoteInit-forkSystemServer"><a href="#ZygoteInit-forkSystemServer" class="headerlink" title="ZygoteInit.forkSystemServer"></a>ZygoteInit.forkSystemServer</h2><p>方法的主要工作：</p><ol><li>创建 SystemServer 所在的进程 system_server ；</li><li>一些初始化；</li><li>初始化 SystemServer 进程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* Prepare the arguments and forks for the system server process.<br>*<br>* <span class="hljs-doctag">@return</span> A &#123;<span class="hljs-doctag">@code</span> Runnable&#125; that provides an entrypoint into system_server code in the child<br>* process; &#123;<span class="hljs-doctag">@code</span> null&#125; in the parent.<br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">forkSystemServer</span><span class="hljs-params">(String abiList, String socketName,<br>       ZygoteServer zygoteServer)</span> </span>&#123;<br> ...<br>     <span class="hljs-comment">/* Hardcoded command line to start the system server */</span><br>     <span class="hljs-comment">// 设置 system_server 的启动参数</span><br>        String args[] = &#123;<br>                <span class="hljs-string">"--setuid=1000"</span>,<br>                <span class="hljs-string">"--setgid=1000"</span>,<br>                <span class="hljs-string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,"</span><br>                        + <span class="hljs-string">"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011"</span>,<br>                <span class="hljs-string">"--capabilities="</span> + capabilities + <span class="hljs-string">","</span> + capabilities,<br>                <span class="hljs-string">"--nice-name=system_server"</span>,<br>                <span class="hljs-string">"--runtime-args"</span>,<br>                <span class="hljs-string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,<br>                <span class="hljs-string">"com.android.server.SystemServer"</span>,<br>        &#125;;<br>        ZygoteArguments parsedArgs = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> pid;<br>        ...<br>        parsedArgs = <span class="hljs-keyword">new</span> ZygoteArguments(args);<br>        ...<br>        <span class="hljs-comment">/* Request to fork the system server process */</span><br>        <span class="hljs-comment">//进入 native 方法去 fork 进程</span><br>        pid = Zygote.forkSystemServer(<br>                    parsedArgs.mUid, parsedArgs.mGid,<br>                    parsedArgs.mGids,<br>                    parsedArgs.mRuntimeFlags,<br>                    <span class="hljs-keyword">null</span>,<br>                    parsedArgs.mPermittedCapabilities,<br>                    parsedArgs.mEffectiveCapabilities);<br>        <span class="hljs-comment">/* For child process */</span><br>        <span class="hljs-comment">//如果是system_server的子进程，pid=0</span><br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (hasSecondZygote(abiList)) &#123;<br>                waitForSecondaryZygote(socketName);<br>            &#125;<br>            zygoteServer.closeServerSocket();<br>            <span class="hljs-comment">//3.初始化 SystemServer 进程</span><br>            <span class="hljs-keyword">return</span> handleSystemServerProcess(parsedArgs);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h2 id="ZygoteInit-handleSystemServerProcess"><a href="#ZygoteInit-handleSystemServerProcess" class="headerlink" title="ZygoteInit.handleSystemServerProcess"></a>ZygoteInit.handleSystemServerProcess</h2><p>这里负责 SystemServer 进程剩余的初始化，最后调用 SystemServer 的 main 方法。</p><p>SystemServer 中会继续初始化 AMS、PMS 和 WMS 等重要服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**<br> * Finish remaining work for the newly forked system server process.<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title">handleSystemServerProcess</span><span class="hljs-params">(ZygoteArguments parsedArgs)</span> </span>&#123;<br>...<br><span class="hljs-keyword">if</span> (parsedArgs.mNiceName != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">//设置进程名为 system_server</span><br>        Process.setArgV0(parsedArgs.mNiceName);<br>    &#125;<br>    ...<br>     <span class="hljs-keyword">if</span> (systemServerClasspath != <span class="hljs-keyword">null</span>) &#123;<br>       <span class="hljs-comment">// 找到ClassLoader </span><br>          cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion);<br>          Thread.currentThread().setContextClassLoader(cl);<br>      &#125;<br><br>      <span class="hljs-comment">/*<br>       * Pass the remaining arguments to SystemServer.<br>       */</span><br>      <span class="hljs-comment">//在zygoteInit方法内做一些参数初始，</span><br>      <span class="hljs-comment">//最后调用RuntimeInit.applicationInit 方法，调起com.android.server.SystemServer的 main 方法。</span><br>      <span class="hljs-keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,<br>              parsedArgs.mDisabledCompatChanges,<br>              parsedArgs.mRemainingArgs, cl);<br></code></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>最后以一图概括整个 zygote 启动流程，就很明了了。</p><p><img src="Zygote%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="Zygote启动流程.png"></p><p>SystemServer 内的初始化更复杂，后续继续查看学习。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/1dee610cf074" target="_blank" rel="noopener">Android世界的起源 — Zygote</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
      <tag>Zygote</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记HashMap相关</title>
    <link href="/2020/04/26/%E5%B0%8F%E8%AE%B0HashMap%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/04/26/%E5%B0%8F%E8%AE%B0HashMap%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>代码版本：<a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:libcore/ojluni/src/main/java/java/util/HashMap.java" target="_blank" rel="noopener">java/util/HashMap.java @ Android-10.0.0_r30</a></p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap 是 Android、Java 面试的常客，阅读学习其源码还是很有必要的。总之先来一个 HashMap 的整体结构，然后顺着慢慢分析。</p><p><img src="HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg" srcset="/img/loading.gif" alt="HashMap存储结构.jpg"></p><p>HashMap 的存储结构由数组、链表和红黑树组成，JDK1.8 之前没有使用红黑树。</p><h1 id="构造-HashMap"><a href="#构造-HashMap" class="headerlink" title="构造 HashMap"></a>构造 HashMap</h1><p>HashMap 的构建有两个重要的参数：</p><ul><li>initialCapacity，初始容量</li><li>loadFactor，负载因子，和扩容有关，默认值 0.75</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>       ...<br>       <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>       <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>   &#125;<br></code></pre></td></tr></table></figure><p>initialCapacity 参数传入 tableSizeFor 方法内算出一个扩容触发的 threshold 阈值。</p><blockquote><p>threshold: The next size value at which to resize (capacity * load factor).</p></blockquote><p>先看一下 tableSizeFor 方法，这个方法目的是为了找到<strong>不小于  cap 的最小的 2的幂</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * Returns a power of two size for the given target capacity.<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么需要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>是因为如果 cap 已经是2 的幂而不减 1，经过下面的位运算之后会得到 cap 的 2 倍。</p><p>这段算法比较抽象，借图表示一下：</p><p><img src="tableSizeFor.jpeg" srcset="/img/loading.gif" alt="tableSizeFor.jpeg"></p><p>因为 Integer 是 32bit ，算法移动到 16bit 的时候最多就是 32 个 1 了，所以最后可能产生负数。</p><p>实际上在构造方法里 threshold 的值并没有乘上load factor，而是推迟到了 put 方法调用的时候，重新更新 threshold 的值。</p><h1 id="插入或更新数据-——-put"><a href="#插入或更新数据-——-put" class="headerlink" title="插入或更新数据 —— put"></a>插入或更新数据 —— put</h1><h2 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>put 方法是最复杂的地方之一，虽然入口方法只有一行代码…</p><p>首先重新对传入的 key 进行 hash 计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>   * Computes key.hashCode() and spreads (XORs) higher bits of hash<br>   * to lower.  Because the table uses power-of-two masking, sets of<br>   * hashes that vary only in bits above the current mask will<br>   * always collide. (Among known examples are sets of Float keys<br>   * holding consecutive whole numbers in small tables.)  So we<br>   * apply a transform that spreads the impact of higher bits<br>   * downward. There is a tradeoff between speed, utility, and<br>   * quality of bit-spreading. Because many common sets of hashes<br>   * are already reasonably distributed (so don't benefit from<br>   * spreading), and because we use trees to handle large sets of<br>   * collisions in bins, we just XOR some shifted bits in the<br>   * cheapest possible way to reduce systematic lossage, as well as<br>   * to incorporate impact of the highest bits that would otherwise<br>   * never be used in index calculations because of table bounds.<br>   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>      <span class="hljs-keyword">int</span> h;<br>      <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里为什么要重新计算一次 hash 而不使用原来的？这个和 table 的 index 计算有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">n = table.length;<br>index = （n-<span class="hljs-number">1</span>） &amp; hash;<br></code></pre></td></tr></table></figure><p>假设 table.length=2^4=16，经过计算会发现只有后 4 位参与了运算。</p><p><img src="hash%E6%96%B9%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="hash方法.jpeg"></p><p>因为数据表长度是 2 的幂，在没有高位参与运算的时候，特别在数据表较短的时候容易产生碰撞，方案考虑现在 hashcode 比较成熟，综合性能与效率，仅做一次高低位异或就可以减少大部分冲突。</p><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>在 putVal 之前先研究一下 resize 容量调整方法，在这个方法里不只是扩容这么简单，它主要做了：</p><ul><li>table 初始化</li><li>扩容复制</li><li>拆分链表、红黑树，提高查询效率</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>     * Initializes or doubles table size.  If null, allocates in<br>     * accord with initial capacity target held in field threshold.<br>     * Otherwise, because we are using power-of-two expansion, the<br>     * elements from each bin must either stay at same index, or move<br>     * with a power of two offset in the new table.<br>     *<br>     * <span class="hljs-doctag">@return</span> the table<br>     */</span><br>    <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>        Node&lt;K,V&gt;[] oldTab = table;<br>        <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>        <span class="hljs-keyword">int</span> oldThr = threshold;<br>        <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//已经初始化过了</span><br>            <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>                <span class="hljs-comment">//防止越界</span><br>                threshold = Integer.MAX_VALUE;<br>                <span class="hljs-keyword">return</span> oldTab;<br>            &#125;<br>            <span class="hljs-comment">//1.扩大新容量为原来的两倍。左移 1 位乘以 2，移 2 位就是乘以 4。</span><br>            <span class="hljs-comment">//2.如果新容量小于最大容量，并且旧容量大于默认初始容量（16），更新新的阈值到原来两倍</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>            <span class="hljs-comment">// 只有 table初始化的时候才会进入这个分支，新容量跟构造时候算出来的阈值一样</span><br>            newCap = oldThr;<br>        <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>            <span class="hljs-comment">// 也是table初始化的时候，但是构造时候没有设置阈值，使用默认的容量和阈值。</span><br>            newCap = DEFAULT_INITIAL_CAPACITY;<br>            newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 根据新容量更新新的阈值，上文构建方法的时候提到过</span><br>            <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                      (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>        &#125;<br>        threshold = newThr;<br>        <span class="hljs-comment">//根据新容量创建新的 table 数组</span><br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>        table = newTab;<br>        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//开始复制旧的数据到新数组上</span><br>            <span class="hljs-comment">//复制时候需要保证元素还在原来的 index 上，或者以 2 次幂偏量移动</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>                Node&lt;K,V&gt; e;<br>                <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//释放旧 table 的引用</span><br>                    oldTab[j] = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                        <span class="hljs-comment">// 如果是普通节点，直接计算 e 在新数组上的 index</span><br>                        newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                        <span class="hljs-comment">//拆分树节点或者取消树化，将子树或者节点分摊在新table对应的位置上</span><br>                        <span class="hljs-comment">//目的：容量大了就不需要这么高的树了，提高查询效率</span><br>                        ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                    <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                        <span class="hljs-comment">// 这里做链表的拆分，链表拆成高低位 2 个。</span><br>                        Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                        Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                        Node&lt;K,V&gt; next;<br>                        <span class="hljs-keyword">do</span> &#123;<br>                            next = e.next;<br>                            <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                    loHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    loTail.next = e;<br>                                loTail = e;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                    hiHead = e;<br>                                <span class="hljs-keyword">else</span><br>                                    hiTail.next = e;<br>                                hiTail = e;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                        <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                            loTail.next = <span class="hljs-keyword">null</span>;<br>                            <span class="hljs-comment">//低位链表在原来的位置</span><br>                            newTab[j] = loHead;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                            hiTail.next = <span class="hljs-keyword">null</span>;<br>                            <span class="hljs-comment">// 高位链表增加 oldCap 偏移拆分到新的位置上</span><br>                            newTab[j + oldCap] = hiHead;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newTab;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><p>put 方法最终调用到 putVal 中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>     * Implements Map.put and related methods<br>     *<br>     * <span class="hljs-doctag">@param</span> hash hash for key<br>     * <span class="hljs-doctag">@param</span> key the key<br>     * <span class="hljs-doctag">@param</span> value the value to put<br>     * <span class="hljs-doctag">@param</span> onlyIfAbsent if true, don't change existing value<br>     * <span class="hljs-doctag">@param</span> evict if false, the table is in creation mode.<br>     * <span class="hljs-doctag">@return</span> previous value, or null if none<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>        ...<br></code></pre></td></tr></table></figure><p>table 是一个 Node&lt;K,V&gt;数组，如果是第一次 put 或者数据为空则先进行resize ，得到当前的容量 n 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>           tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure><p>计算插入点 hash 在 table 对应的 index ，如果不存在（不冲突）则直接插入新的 Node。</p><p>如果存在冲突，则有 4 种情况：</p><ol><li>key或者 hash 相同，直接更新；</li><li>插入或更新红黑树；</li><li>插入或更新链表；</li><li>链表转红黑树；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">Node&lt;K,V&gt; e; K k;<br><span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>    ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>    <span class="hljs-comment">//1. hash 和 key 相同或者 key equal，后面直接更新值就可以</span><br>    e = p;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>   <span class="hljs-comment">//2. 原来的节点已经是红黑树了，那么插入或更新红黑树</span><br>    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br><span class="hljs-keyword">else</span> &#123;<br>   <span class="hljs-comment">//3. 尝试插入链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>        <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>            p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>           <span class="hljs-comment">// 4. 如果链表长度大于阈值TREEIFY_THRESHOLD（8），则把链表转成红黑树</span><br>            <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                treeifyBin(tab, hash);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>           <span class="hljs-comment">// 链表有相同的节点了，更新值就可以</span><br>            <span class="hljs-keyword">break</span>;<br>        p = e;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>    V oldValue = e.value;<br>    <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>       <span class="hljs-comment">// 更新新的数据</span><br>        e.value = value;<br>    afterNodeAccess(e);<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后插入或更新完成后，根据阈值判断是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (++size &gt; threshold)<br>       resize();<br></code></pre></td></tr></table></figure><h1 id="获取数据-——-get"><a href="#获取数据-——-get" class="headerlink" title="获取数据 —— get"></a>获取数据 —— get</h1><p>相对 put ，get 的流程就很简单了，无非就是计算 hash 直接去对应位置取，如果是链表或红黑树就进行查找。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>HashMap 的代码格式实在是一言难尽，可读性较差。</p><p>看完之后对一些面试常见的问题也有了答案，例如</p><blockquote><p>构建 HashMap 传入容量 100 和加载因子 0.75 ，put 的时候放入 95 个数据，会触发扩容吗？</p></blockquote><p>答案是不会，因为在构建时 threshold 被计算为 128。首次put的时候，table 初始化的大小等于 threshold ，threshold 的值被更新为 128 * 0.75 = 96 ，所以 put 95 个数据不会触发扩容。</p><p>todo：hash 冲突的算法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">HashMap源码注解 之 静态工具方法hash()、tableSizeFor()（四）</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码</tag>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记Android消息处理机制和同步屏障</title>
    <link href="/2020/04/25/%E5%B0%8F%E8%AE%B0Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/"/>
    <url>/2020/04/25/%E5%B0%8F%E8%AE%B0Android%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C/</url>
    
    <content type="html"><![CDATA[<p>代码版本： <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30" target="_blank" rel="noopener">Android-10.0.0_r30</a></p><h1 id="消息处理架构"><a href="#消息处理架构" class="headerlink" title="消息处理架构"></a>消息处理架构</h1><p>在Java层上，Android实现消息处理机制主要有以下几个类：</p><ul><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Handler.java" target="_blank" rel="noopener">android/os/Handler.java</a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Message.java" target="_blank" rel="noopener">android/os/Message.java</a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Looper.java" target="_blank" rel="noopener">android/os/Looper.java</a></li><li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="noopener">android/os/MessageQueue.java</a></li></ul><p>虽然它们之间的关系比较简单，但如果要深究其原理还是非常复杂的，特别是到native层部分。</p><p><img src="%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" alt="消息机制架构.png"></p><p>如图所示，Handler负责处理消息，类似一个句柄，其他线程可以向其发送 Message ， Message 进入消息队列 MessageQueue 中，一个运行在主线程的 Looper 不断从队列中取出消息，然后调用其 Handler 或者 Callback 处理逻辑。</p><h1 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h1><h2 id="构建Looper"><a href="#构建Looper" class="headerlink" title="构建Looper"></a>构建Looper</h2><p>Looper 的内部维护了一个 MessageQueue 对象，在线程中调用 Looper.prepare 来创建新的 Looper。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>      Handler handler;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-comment">// 必须先调用</span><br>          Looper.prepare();<br>          <span class="hljs-comment">//用 Looper 来创建 Handler</span><br>          handler = <span class="hljs-keyword">new</span> Handler(Looper.myLooper());<br>          Looper.loop();<br>      &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>Looper#prepare 方法里，构建一个新的 Looper 对象，然后将其放入静态的<br> sThreadLocal 中。</p><blockquote><p>ThreadLocal: This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. </p></blockquote><p>如果重复调用 prepare 会抛出异常，所以<strong>每个线程只能有一个 Looper</strong>。</p><p>在主线程（UI Thread）中不需要创建 Looper，因为在应用 ActivityThread 创建出来的时候，在 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/app/ActivityThread.java;l=7329;drc=0a9ee1af2cba8da1de3aace999d8547503c06f4c" target="_blank" rel="noopener">main</a> 方法中已经调用过 Looper#prepareMainLooper 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Only one Looper may be created per thread"</span>);<br>        &#125;<br>        sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br>    &#125;<br></code></pre></td></tr></table></figure><p>最后调用 Looper#loop 方法，创建一个 MessageQueue 并循环等待调用其 next 方法得到下一条要被处理的消息，将这个消息分发给对应的处理者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">final</span> Looper me = myLooper();<br>...<br>        <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;<br>        ...<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Message msg = queue.next(); <span class="hljs-comment">// might block</span><br>            ...<br>            <span class="hljs-comment">// 分发事件给 target 处理，也就是消息对应的 Handler</span><br>            msg.target.dispatchMessage(msg); <br>            ...<br>            <span class="hljs-comment">// 回收 Message</span><br>            msg.recycleUnchecked();<br>        &#125;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里Looper 的主要工作就结束了。</p><h2 id="构建Handler"><a href="#构建Handler" class="headerlink" title="构建Handler"></a>构建Handler</h2><p>Handler 的构建必须依赖 Looper 作为参数，否则就是无效 Handler，即使在主线程创建，Google 官方还是推荐使用以 Looper 作为参数的构建方式来创建 Handler，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Handler h = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br></code></pre></td></tr></table></figure><p>在新版的代码中可以看到，Handler 的无参构建方法已经标记为 Deprecated 了，目的是避免错误隐患和保证代码可读性。</p><p>Handler 还有几个被 hide 的构造方法，和异步消息有关，后续继续分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* <span class="hljs-doctag">@hide</span><br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, async);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Handler-处理消息"><a href="#Handler-处理消息" class="headerlink" title="Handler 处理消息"></a>Handler 处理消息</h2><p>Handler 的 dispatchMessage 方法负责接收 Looper 分发的消息，可以看到消息处理的优先级：</p><p>Message 内的 callback &gt; Handler 的 callback &gt; handleMessage 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(@NonNull Message msg)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;<br>           handleCallback(msg); <span class="hljs-comment">// 1</span><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;<br>               <span class="hljs-comment">// 2</span><br>               <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>           &#125;<br>           handleMessage(msg); <span class="hljs-comment">// 3</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h1><h2 id="构造-Message"><a href="#构造-Message" class="headerlink" title="构造 Message"></a>构造 Message</h2><p>构造一个 Message 对象可以直接 new 一个出来，但是一般都使用 Message.obtain() 从对象池中获取，否则如果消息频率太高会导致短时间内存占用上升，虚拟机频繁 <a href="https://hoholidayx.github.io/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B3%95">GC</a>  影响性能。</p><p>Message 其实是链表结构，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> what;<br>    ...<br>    <span class="hljs-comment">// sometimes we store linked lists of these things</span><br>    <span class="hljs-comment">/*package*/</span> Message next;<br>    ...<br>    <span class="hljs-comment">// 对象池起始当前节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message sPool;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用一个静态 sPool 变量表示当前对象池链表的头节点，通过 obtain 方法获取 Message 的时候把头结点从链表移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">obtain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-keyword">null</span>) &#123;<br>            Message m = sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-keyword">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Message();<br>&#125;<br></code></pre></td></tr></table></figure><p>Message 使用完后调用 recycle 方法进入 recycleUncheckd ，将当前Message插入回链表头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<br>    next = sPool;<br>    sPool = <span class="hljs-keyword">this</span>;<br>    sPoolSize++;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以实际上这个对象池是一个用链表实现的栈。</p><h2 id="通过-Handler-发送-Message"><a href="#通过-Handler-发送-Message" class="headerlink" title="通过 Handler 发送 Message"></a>通过 Handler 发送 Message</h2><p>调用 Handler 的 sendMessage 方法，最后到 sendMessageAtTime 中，向 MessageQueue 入队消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(@NonNull MessageQueue queue, @NonNull Message msg,<br>           <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>       msg.target = <span class="hljs-keyword">this</span>;<br>       msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>       <span class="hljs-comment">//异步消息</span><br>       <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>           msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>       &#125;<br>       <span class="hljs-comment">//消息入队</span><br>       <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="在-MessageQueue-中插入-Message"><a href="#在-MessageQueue-中插入-Message" class="headerlink" title="在 MessageQueue 中插入 Message"></a>在 MessageQueue 中插入 Message</h2><p>在 enqueueMessage 中主要做了几件事：</p><ol><li>将消息标记为已使用；</li><li>按照消息的发送时间 （uptimeMillis）将消息插入队列中的对应位置；</li><li>判断是否要 wakeup 一次 next 方法的等待；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Message must have a target."</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">" This message is already in use."</span>);<br>       &#125;<br><br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>           <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>               IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(<br>                       msg.target + <span class="hljs-string">" sending message to a Handler on a dead thread"</span>);<br>               Log.w(TAG, e.getMessage(), e);<br>               msg.recycle();<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           &#125;<br>           <span class="hljs-comment">// 标记消息为已使用</span><br>           msg.markInUse();<br>           msg.when = when;<br>           Message p = mMessages;<br>           <span class="hljs-keyword">boolean</span> needWake;<br>           <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>           <span class="hljs-comment">// 队列为空，或者需要立即发送或发送时间快于队首</span><br>               <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>               msg.next = p;<br>               mMessages = msg;<br>               needWake = mBlocked;<span class="hljs-comment">//有新的消息，如果当前是 block 状态则需要 wakeup</span><br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span><br>               <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>               <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>               <span class="hljs-comment">// 除非是当前队首是同步屏障，并且这个消息是最早的异步消息，否则不需要 wakeup</span><br>               needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>               Message prev;<br>               <span class="hljs-comment">// 循环找到发送时间大于当前消息的节点，将其插入找到的这个节点之前</span><br>               <span class="hljs-keyword">for</span> (;;) &#123;<br>                   prev = p;<br>                   p = p.next;<br>                   <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                       <span class="hljs-keyword">break</span>;<br>                   &#125;<br>                   <span class="hljs-comment">//如果后面的节点有异步消息，则这一次插入不需要wakeup</span><br>                   <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                       needWake = <span class="hljs-keyword">false</span>;<br>                   &#125;<br>               &#125;<br>               msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>               prev.next = msg;<br>           &#125;<br><br>           <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>           <span class="hljs-keyword">if</span> (needWake) &#123;<br>               nativeWake(mPtr);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="MessageQueue-next-返回给-Looper-消息"><a href="#MessageQueue-next-返回给-Looper-消息" class="headerlink" title="MessageQueue.next 返回给 Looper 消息"></a>MessageQueue.next 返回给 Looper 消息</h2><p>next 方法有个大循环持续 wait &amp; get ，直到队列中取出合适的消息返回给 Looper 使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>    ...<br>    <span class="hljs-comment">//该方法会持续 block，直到超时或者被 nativeWake 方法唤醒</span><br>    nativePollOnce(ptr, nextPollTimeoutMillis);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>        Message prevMsg = <span class="hljs-keyword">null</span>;<br>        Message msg = mMessages;<br>        <span class="hljs-comment">//和异步消息有关，后续分析</span><br>        <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                prevMsg = msg;<br>                msg = msg.next;<br>            &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>            <span class="hljs-comment">//如果取出来的时间还没到，更新nextPollTimeoutMillis继续调用nativePollOnce等待</span><br>                <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Got a message.</span><br>                mBlocked = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">//将消息从队列中移除</span><br>                <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>                    prevMsg.next = msg.next;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mMessages = msg.next;<br>                &#125;<br>                msg.next = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">"Returning message: "</span> + msg);<br>                msg.markInUse();<br>                <span class="hljs-keyword">return</span> msg;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// No more messages.</span><br>            nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>        &#125;<br>...<br>&#125;<br>...<br></code></pre></td></tr></table></figure><h1 id="消息同步屏障"><a href="#消息同步屏障" class="headerlink" title="消息同步屏障"></a>消息同步屏障</h1><h2 id="什么是同步屏障"><a href="#什么是同步屏障" class="headerlink" title="什么是同步屏障"></a>什么是同步屏障</h2><p>同步屏障是 MeesageQueue 中一种特殊的机制，源码注释如下，</p><blockquote><p>Message processing occurs as usual until the message queue encounters the<br>synchronization barrier that has been posted.  When the barrier is encountered,<br>later synchronous messages in the queue are stalled (prevented from being executed) until the barrier is released by calling {@link #removeSyncBarrier} and specifying the token that identifies the synchronization barrier.</p></blockquote><p>大概意思就是同步屏障是阻碍正常消息队列循环的一种手段，这个屏障会阻碍同步消息也就是平时我们发送的消息的循环，而异步消息还是正常发送，所以异步消息和同步屏障通常是搭配使用的。如下图所示：</p><p><img src="%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C.png" srcset="/img/loading.gif" alt="同步屏障.png"></p><p>同步屏障的意义简单来说，就像游戏服务器拥挤的时候，异步消息就是 VIP 玩家可以优先登录游戏，而普通玩家需要等到服务器缓解的时候才能登录。实际上在 Android 中，同步屏障的意义也是在于此，例如屏幕的绘制信号。</p><h2 id="同步屏障实现"><a href="#同步屏障实现" class="headerlink" title="同步屏障实现"></a>同步屏障实现</h2><h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>调用 MessageQueue 的 postSyncBarrier 放置一个同步屏障，when 参数指定屏障发生的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>       <span class="hljs-comment">// Enqueue a new sync barrier token.</span><br>       <span class="hljs-comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span><br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> token = mNextBarrierToken++;<br>           <span class="hljs-keyword">final</span> Message msg = Message.obtain();<br>           msg.markInUse();<br>           msg.when = when;<br>           msg.arg1 = token;<br><br>           Message prev = <span class="hljs-keyword">null</span>;<br>           Message p = mMessages;<br>           <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                   prev = p;<br>                   p = p.next;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span><br>               msg.next = p;<br>               prev.next = msg;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               msg.next = p;<br>               mMessages = msg;<br>           &#125;<br>           <span class="hljs-keyword">return</span> token;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>从源码可以看出其实这个屏障就是一个特殊的 Message，它没有对应的 Handler，所以 target 为空，这条消息的插入逻辑和普通消息的插入是一样，但是这个插入不会唤醒 block 住的 poll 循环。</p><h3 id="处理屏障"><a href="#处理屏障" class="headerlink" title="处理屏障"></a>处理屏障</h3><p>同步屏障也是在 next 方法中实现的，上文 next 的源码中有一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>Message prevMsg = <span class="hljs-keyword">null</span>;<br>Message msg = mMessages;<br><span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>  <span class="hljs-comment">// 在这里实现同步屏障。如果当前队首消息是屏障消息（target==null），那么就循环寻找下一条异步消息取出队列。</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        prevMsg = msg;<br>        msg = msg.next;<br>    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很短，很巧妙的就实现了这样的一个重要的功能。</p><h3 id="移除屏障"><a href="#移除屏障" class="headerlink" title="移除屏障"></a>移除屏障</h3><p>放置了同步屏障一定要在合适的时候进行移除，例如期望的异步消息得到了回调，不然这个屏障会一直存在，导致正常的同步消息无法正常回调！</p><p>通过调用 removeSyncBarrier 方法进行移除，传入 postSyncBarrier 返回的 token 作为参数，标识需要移除哪个屏障，然后将该屏障消息会从队列中移除。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>到此 Java 层的消息机制实现基本分析完毕了，代码虽然不多架构也比较简单，但不失为学习阅读 Android 源码的好例子。</p><p>在 Android2.3 之前是只有 Java 层上有这套代码，在之后 Native 层也实现了一套类似的机制，本文还没有对 native 部分代码进行深究，后续有时间会继续更新。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>源码</tag>
      
      <tag>消息机制</tag>
      
      <tag>Handler</tag>
      
      <tag>Message</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下搭建CUDA+cuDNN+tf+Python环境</title>
    <link href="/2020/04/22/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BACUDA+cuDNN+tf+Python%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/04/22/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BACUDA+cuDNN+tf+Python%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="安装NVIDIA-CUDA"><a href="#安装NVIDIA-CUDA" class="headerlink" title="安装NVIDIA CUDA"></a>安装NVIDIA CUDA</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>Ubuntu：16.0.4</li><li>Toolkit：10.0</li><li>cuDNN：7.5.1 (April 22, 2019) for CUDA 10.0</li></ul><ol><li><a href="https://developer.nvidia.com/cuda-10.0-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=runfilelocal" target="_blank" rel="noopener">官网下载CUDA Toolkit</a></li></ol><p>安装cuda之前需要先安装gcc、g++和 build-essential等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install build-essential gcc g++ make binutils linux-headers-`uname -r`<br></code></pre></td></tr></table></figure><p>运行安装脚本即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sh cuda_10.0.130_410.48_linux.run<br></code></pre></td></tr></table></figure><p>配置CUDA环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>export PATH=/usr/local/cuda-10.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;<br>export LD_LIBRARY_PATH=/usr/local/cuda-10.0/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;<br><br>source ~/.bashrc<br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://developer.nvidia.com/rdp/form/cudnn-download-survey" target="_blank" rel="noopener">下载</a>cuDNN</li></ol><ul><li><p><a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v7.5.1/prod/10.0_20190418/Ubuntu16_04-x64/libcudnn7-dev_7.5.1.10-1%2Bcuda10.0_amd64.deb" target="_blank" rel="noopener">dev包</a></p></li><li><p><a href="https://developer.nvidia.com/compute/machine-learning/cudnn/secure/v7.5.1/prod/10.0_20190418/Ubuntu16_04-x64/libcudnn7_7.5.1.10-1%2Bcuda10.0_amd64.deb" target="_blank" rel="noopener">runtime包</a></p></li></ul><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">dpkg -i libcudnn7-dev_7.5.1.10-1%2Bcuda10.0_amd64.deb<br>dpkg -i libcudnn7_7.5.1.10-1%2Bcuda10.0_amd64.deb<br></code></pre></td></tr></table></figure><h1 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h1><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><ol><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">官网</a>下载需要的版本</li><li>将源码解压缩，进入到目录内编译安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><h2 id="通过PPA源安装Python"><a href="#通过PPA源安装Python" class="headerlink" title="通过PPA源安装Python"></a>通过PPA源安装Python</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sudo apt-get install software-properties-common<br><br>sudo add-apt-repository ppa:deadsnakes/ppa<br><br>sudo apt-get update<br><br>sudo apt-get install python3.6 python3-pip<br><br>python3.6 -m pip install [Package_to_install]<br></code></pre></td></tr></table></figure><h1 id="安装Tensorflow-gpu"><a href="#安装Tensorflow-gpu" class="headerlink" title="安装Tensorflow-gpu"></a>安装Tensorflow-gpu</h1><p>按照上面的cuda和cuDNN版本，这里只能装1.14.0的，不然会提示与cuDNN版本不兼容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3.6 -m pip install tensorflow==1.14.0 tensorflow-gpu==1.14.0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Ubuntu进行StyleGAN2训练Google Colab版</title>
    <link href="/2020/03/31/%E5%9C%A8Ubuntu%E8%BF%9B%E8%A1%8CStyleGAN2%E8%AE%AD%E7%BB%83Google%20Colab%E7%89%88/"/>
    <url>/2020/03/31/%E5%9C%A8Ubuntu%E8%BF%9B%E8%A1%8CStyleGAN2%E8%AE%AD%E7%BB%83Google%20Colab%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h1><ul><li>稳定的梯子</li><li>谷歌账号(有钱最好，新用户可以试用300$)</li><li>训练集</li></ul><h1 id="准备训练集"><a href="#准备训练集" class="headerlink" title="准备训练集"></a>准备训练集</h1><p>如果只想走一下流程的话，随便准备百来张图片就可以了，毕竟跑一次训练成本很高，支持的图片尺寸有256x256，512x512和1024x1024。</p><p>推荐一个国内的网站<a href="http://www.seeprettyface.com/" target="_blank" rel="noopener">seeprettyface</a>，有不少产品和免费的图库下载。</p><p>StyleGAN2不能支持直接输入图片，需要用官方提供的dataset_tool.py将原始图片转换成Tensorflow的tfrecords格式，会占用更大的空间，所以需要预留好硬盘。</p><h1 id="下载StyleGAN2源码"><a href="#下载StyleGAN2源码" class="headerlink" title="下载StyleGAN2源码"></a>下载StyleGAN2源码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">%</span><span class="bash">tensorflow_version 1.x</span><br><br>!git clone https://github.com/NVlabs/stylegan2<br><span class="hljs-meta">%</span><span class="bash"><span class="hljs-built_in">cd</span> stylegan2</span><br></code></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cloning into 'stylegan2'...<br>remote: Enumerating objects: 7, done.<br>remote: Counting objects: 100% (7/7), done.<br>remote: Compressing objects: 100% (7/7), done.<br>remote: Total 117 (delta 2), reused 3 (delta 0), pack-reused 110<br>Receiving objects: 100% (117/117), 587.49 KiB | 21.76 MiB/s, done.<br>Resolving deltas: 100% (47/47), done.<br>/content/stylegan2<br></code></pre></td></tr></table></figure><h2 id="源码修改"><a href="#源码修改" class="headerlink" title="源码修改"></a>源码修改</h2><h3 id="如发生错误C-versions-less-than-C-11-are-not-supported"><a href="#如发生错误C-versions-less-than-C-11-are-not-supported" class="headerlink" title="如发生错误C++ versions less than C++11 are not supported"></a>如发生错误C++ versions less than C++11 are not supported</h3><p>修改文件  dnnlib/tflib/custom_ops.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">cmd = opts.strip()<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cmd = <span class="hljs-string">'nvcc --std=c++11 -DNDEBUG '</span> + opts.strip()<br>`<br></code></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="一般虚拟机-GPU"><a href="#一般虚拟机-GPU" class="headerlink" title="一般虚拟机(GPU)"></a>一般虚拟机(GPU)</h2><p>配置StyleGAN2的运行环境主要需要以下几点：</p><ol><li><a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener">NVIDIA CUDA Toolkit(含驱动)</a></li><li><a href="https://developer.nvidia.com/rdp/form/cudnn-download-survey" target="_blank" rel="noopener">NVIDIA cuDNN (需要登录)</a></li><li><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python3.6</a></li><li><a href="https://www.tensorflow.org/install/gpu" target="_blank" rel="noopener">Tensorflow-gpu</a></li></ol><p>这些东西的配置逛网和网上都有很多教程了，安装的顺序按照上述就行。</p><p>如果是阿里云的服务器，不要选择“GPU虚拟化”的类型，驱动各种装不上，选“GPU计算型”即可，懒的话还可以用阿里提供的<a href="https://help.aliyun.com/document_detail/60149.html?spm=5176.ecsbuyv3.0.0.c5c23675LahT5D#section-bl2-k23-ygb" target="_blank" rel="noopener">自动安装脚本</a>安装驱动+cuda+cnDUU。</p><p><strong>其他python依赖</strong>：</p><ul><li>numpy</li><li>scipy==1.3.3</li><li>requests==2.22.0</li><li>Pillow==6.2.1</li></ul><h2 id="Google-Colab"><a href="#Google-Colab" class="headerlink" title="Google Colab"></a>Google Colab</h2><ol><li>将数据集放到Drive内</li><li>挂载 Google Drive</li><li><del>充值 Google Colab Pro</del></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#挂载 Google Drive</span><br><span class="hljs-keyword">from</span> google.colab <span class="hljs-keyword">import</span> drive<br>drive.mount(<span class="hljs-string">'/content/drive'</span>)<br></code></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Go to this URL in a browser: [https://accounts.google.com/o/oauth2/auth?client_id=...)<br> Enter your authorization code: ·········· Mounted at /content/drive<br></code></pre></td></tr></table></figure><h1 id="转换图片为数据集"><a href="#转换图片为数据集" class="headerlink" title="转换图片为数据集"></a>转换图片为数据集</h1><p>因为StyleGAN2不能直接输入原始图片，所以需要转成tfrecords格式。</p><p>python dataset_tool.py create_from_images  <strong>TF_RECORD的输出路径</strong>   <strong>输入的图片集合</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!python dataset_tool.py create_from_images /content/drive/My\ Drive/download/datasets/mysets /content/drive/My\ Drive/download/images<br></code></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shel">Loading images from &quot;&#x2F;content&#x2F;drive&#x2F;My Drive&#x2F;download&#x2F;images&quot;<br>Creating dataset &quot;&#x2F;content&#x2F;drive&#x2F;My Drive&#x2F;download&#x2F;images_tf_records&quot;<br>Added 151 images.<br></code></pre></td></tr></table></figure><h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><h2 id="检查运行环境"><a href="#检查运行环境" class="headerlink" title="检查运行环境"></a>检查运行环境</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查运行环境</span><br><br>!nvcc test_nvcc.cu -o test_nvcc -run<br>!nvidia-smi -L<br><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>print(<span class="hljs-string">'Tensorflow version: &#123;&#125;'</span>.format(tf.__version__) )<br>print(<span class="hljs-string">'GPU Identified at: &#123;&#125;'</span>.format(tf.test.gpu_device_name()))<br></code></pre></td></tr></table></figure><p>outputs:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">CPU says hello.<br>GPU says hello.<br>Tensorflow version: 1.15.0<br>GPU 0: Tesla P100-PCIE-16GB (UUID: GPU-99160cdb-b950-8328-38c2-b9a0b9128643)<br>GPU Identified at: /device:GPU:0<br></code></pre></td></tr></table></figure><h2 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h2><p>run_training.py有3个必须配置的参数：</p><ul><li>config 训练配置项</li><li>data-dir 训练集的位置,例如 /datasets</li><li>dataset 训练集内的子文件夹名字，例如完整路径是/datasets/mysets，这里就输入mysets，</li></ul><p>config：不同的配置影响会训练的时间，具体参见<a href="https://github.com/hoholidayx/stylegan2" target="_blank" rel="noopener">官方文档</a></p><table><thead><tr><th>config</th><th>desc</th></tr></thead><tbody><tr><td>config-a</td><td>Baseline StyleGAN</td></tr><tr><td>config-b</td><td>Weight demodulation</td></tr><tr><td>config-c</td><td>Lazy regularization</td></tr><tr><td>config-d</td><td>Path length regularization</td></tr><tr><td>config-e</td><td>No growing, new G &amp; D arch.</td></tr><tr><td>config-f</td><td>Large networks (default)</td></tr></tbody></table><p>total-kimg：训练的循环次数，默认是25000</p><h2 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 开始训练</span><br>!python ./run_training.py --config "config-f" --total-kimg 10000 --dataset "mysets" --data-dir "/content/drive/My Drive/download/datasets"<br></code></pre></td></tr></table></figure><h1 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h1><p>colab内存不够，看来还是要充值。</p><blockquote><p>tick 0     kimg 0.0      lod 0.00  minibatch 4    time 18s          sec/tick 17.8    sec/kimg 1114.10 </p></blockquote><p>sec/kimg 表示每次循环需要的时间，在GCP上，4 CPUs 、26 GB Mem &amp; K80 GPU，大概时间是 900秒，仅供参考。</p><p>模型训练完后默认保存到results目录下，results/00xxx-stylegan2-{dataset}-{gpu}-{config}/network-final.pkl。</p><h1 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h1><p>这一步骤没有做，因为只是为了过一遍流程和踩坑，具体可以参考<a href="https://github.com/NVlabs/stylegan2#evaluation-metrics" target="_blank" rel="noopener">官方文档</a>，比较简单。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">python run_metrics.py --data-dir=/content/drive/My\ Drive/download/datasets \ <br>--network=stylegan2/results/00000-stylegan2-myset-1gpu-config-f/network-final.pkl \<br>  --metrics=fid50k,ppl2_wend --dataset=myset<br></code></pre></td></tr></table></figure><h1 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3.6 run_generator.py generate-images --network=stylegan2/results/00000-stylegan2-myset-1gpu-config-f/network-final.pkl \<br>  --seeds=66,230,389,1518 --truncation-psi=1.0<br></code></pre></td></tr></table></figure><p>根据seeds得到4个结果：</p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png" srcset="/img/loading.gif" alt="运行结果1.png"></p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png" srcset="/img/loading.gif" alt="运行结果2.png"></p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C3.png" srcset="/img/loading.gif" alt="运行结果3.png"></p><p><img src="%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C4.png" srcset="/img/loading.gif" alt="运行结果4.png"></p><p>因为这次运行的训练集数量很少，循环次数也很少，所以得到的结果也只能如上所示，但是还是依稀可以看到图片的轮廓的。</p><p>如果训练时间足够样本足够的话，正常的过程应该是这样的：</p><p><img src="%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B.gif" srcset="/img/loading.gif" alt="训练过程.gif"></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><p>完整ipynb<a href="https://colab.research.google.com/drive/18TFQScGlCD0WnjAXwPrgcr_KMzcryJ3y" target="_blank" rel="noopener">下载</a>。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>StyleGAN</tag>
      
      <tag>机器学习</tag>
      
      <tag>AI</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Android游戏助手</title>
    <link href="/2020/03/17/%E5%85%B3%E4%BA%8EAndroid%E6%B8%B8%E6%88%8F%E5%8A%A9%E6%89%8B/"/>
    <url>/2020/03/17/%E5%85%B3%E4%BA%8EAndroid%E6%B8%B8%E6%88%8F%E5%8A%A9%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="游戏助手是什么"><a href="#游戏助手是什么" class="headerlink" title="游戏助手是什么"></a>游戏助手是什么</h1><p>终于开始这个系列的填坑了，自上次17年写的文章<a href="https://hoholidayx.github.io/2017/10/08/LuaJava%E5%9C%A8Java%E3%80%81Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">《LuaJava在Java、Android中的使用》</a> 已经过了2年，主要介绍了游戏助手技术栈的其中一项。本文开始将继续记录一些项目中碰到的问题和有价值的经验。<del>项目坟头都长草了祭奠一下。</del></p><p><img src="%E5%BF%83%E5%A1%9E.jpg" srcset="/img/loading.gif" alt="心塞"></p><p>这里游戏助手主要指的是Android端的应用，虽然iOS端也有能够实现的方案，但是成本较高且本人对iOS技术钻研不精，所以不做讨论。</p><p>游戏助手是什么，用我的定义来说，就是</p><ol><li><strong>能帮助玩家自动的去完成一些冗余重复的工作</strong>，例如挂机刷金币，</li><li><strong>或者是增强补充游戏内的某些功能</strong>，例如魔兽世界伤害统计的辅助工具软件。</li></ol><p>下图展示的是<a href="https://cfm.qq.com/" target="_blank" rel="noopener">穿越火线手游</a>自动操作塔防。</p><p><img src="cf%E8%87%AA%E5%8A%A8%E6%B8%B8%E6%88%8F.gif" srcset="/img/loading.gif" alt="cf自动游戏.gif"></p><p><a href="https://pvp.qq.com/" target="_blank" rel="noopener">王者荣耀</a>自动刷冒险设置。</p><p><img src="%E7%8E%8B%E8%80%85%E8%8D%A3%E8%80%80%E8%87%AA%E5%8A%A8%E5%88%B7%E5%86%92%E9%99%A9%E8%AE%BE%E7%BD%AE.png" srcset="/img/loading.gif" alt="王者荣耀自动刷冒险设置"></p><p>这里可能有人会说“这不就是WG嘛”，对的，这东西俗称其实就是WG，但是在这里不讨论什么“道德伦理”问题，技术本身没有好坏，关键在于怎么去使用它。</p><p>在移动端实现游戏助手辅助功能主要有两个流派，以是否读写内存作区分：</p><ul><li>不读写内存</li></ul><p><img src="%E4%B8%8D%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98.jpg" srcset="/img/loading.gif" alt="不读写内存"></p><ul><li>读写内存</li></ul><p><img src="%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98.jpg" srcset="/img/loading.gif" alt="读写内存"></p><h1 id="市面上的产品"><a href="#市面上的产品" class="headerlink" title="市面上的产品"></a>市面上的产品</h1><p>18年再往之前，可以说是这个领域的黄金时期，有着各式各样的种游戏辅助软件，其中时间较长用户规模也比较大的有叉叉助手，还有在末期才出现的游戏超人等，我研究比较多的也就这俩，下面也就拿这两家和我厂的产品来介绍。</p><table><thead><tr><th>产品</th><th>是否需要root</th><th>是否读写内存</th><th>核心技术</th></tr></thead><tbody><tr><td>叉叉助手</td><td>有root和非root版本</td><td>否</td><td>高权限adb shell</td></tr><tr><td>游戏超人</td><td>不需要</td><td>否</td><td>悬浮窗、美工</td></tr><tr><td>我厂AY</td><td>不需要</td><td>是</td><td>沙箱虚拟化</td></tr></tbody></table><h2 id="叉叉助手"><a href="#叉叉助手" class="headerlink" title="叉叉助手"></a>叉叉助手</h2><p>叉叉助手是行业内最有资历的产品，<del>所以后面才被杀鸡儆猴</del>，最早应该是在PC端有不少的资源，后续转战移动端，拥有自己的脚本开发者生态圈，这一点是令人向往的。</p><p><img src="%E5%8F%89%E5%8F%89%E5%8A%A9%E6%89%8B.jpeg" srcset="/img/loading.gif" alt="叉叉助手.jpeg"></p><p>叉叉助手支持手机root和非root使用，核心技术是通过获取adb shell的权限，启动自己的守护和工作进程，通过进程间通信实现屏幕的截图和模拟点击等操作，属于上文说的不读写内存的流派1。</p><p>root的情况下就不说了，什么事情都能干，但是用户群比较小；非root的情况就比较复杂，需要引导用户在PC端上下载“钥匙应用”进行APP的“激活”，本质上就是利用手机与pc端的adb连接，来启动手机的shell进程获取权限。</p><h2 id="游戏超人"><a href="#游戏超人" class="headerlink" title="游戏超人"></a>游戏超人</h2><p>游戏超人应该是猎豹做的一款辅助，我知道它的时候已经是末期了，给我的第一印象就是UI很好看很精细，<del>不像我厂的产品很多UI都是我自己动手的，</del>它提供的功能也比较简单，基本都是游戏界面美化之类的，从下图也可以看出。</p><p><img src="%E6%B8%B8%E6%88%8F%E8%B6%85%E4%BA%BA.jpeg" srcset="/img/loading.gif" alt="游戏超人.jpeg"></p><p>经过分析发现，其实它的核心实现非常简单，就是悬浮窗，剩下的就是怎么制作这些美化UI和这些UI怎么去适配游戏和屏幕分辨率的问题了。</p><h2 id="我厂的游戏助手-AY"><a href="#我厂的游戏助手-AY" class="headerlink" title="我厂的游戏助手-AY"></a>我厂的游戏助手-AY</h2><p>我厂的游戏助手项目简称AY好了，这里不方便透露名字。AY的实现方式集合了上文的两种流派来实现的。</p><p><img src="AY.jpg" srcset="/img/loading.gif" alt="AY.jpg"></p><p>AY依靠分身（沙箱）SDK提供的沙箱环境和多个hook接口，实现了对内存的读写，这里主要是为了实现上文的“输出模拟点击”部分；同时使用Android5.0提供的屏幕录制接口，实现“获取屏幕截图”部分。</p><p>这种方式可以结合两种流派的优点，可以在免root的情况下，不需要像叉叉助手一样复杂的用户引导流程，又可以实现对第三方应用的输出模拟点击，所以AY能比同类产品有更强的能力去做更多的事情，后续的产品迭代也证明了这点。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>到了19年之后就开始这些产品就开始凉了（包括我厂的项目），原因有很多，主要因腾讯加强了对作弊的打压，反作弊SDK不断升级攻防难度加大，投入不抵产出，更主要的原因是政府层面出手打压这块产业，其中最惨的就是叉叉助手，<a href="https://www.sohu.com/a/361203096_120123245" target="_blank" rel="noopener">《叉叉助手公司被查！案值数亿元，也成全国首例违法脚本公司》</a>。</p><p><img src="%E9%BB%98%E5%93%80.jpg" srcset="/img/loading.gif" alt="默哀"></p><p>虽然产业消亡了，但是还是沉淀不少的技术，也许未来还能有用武之地的，例如在自动化测试等…</p>]]></content>
    
    
    <categories>
      
      <category>游戏助手</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>游戏</tag>
      
      <tag>辅助</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LuaJava框架多线程支持修改</title>
    <link href="/2020/03/03/LuaJava%E6%A1%86%E6%9E%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E4%BF%AE%E6%94%B9/"/>
    <url>/2020/03/03/LuaJava%E6%A1%86%E6%9E%B6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>LuaJava框架是不支持多线程调用的，例如在游戏助手里，脚本需要在Java层执行一个异步任务，然后回调通知Lua层，因为Lua是单独跑在一个线程里，而回调是在主线程，所以这时候会发生崩溃或者Lua虚拟机的栈异常。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>这种情况有两种解决方案，一是修改LUA虚拟机，使其在当前线程能够执行post过来的任务，类似Handler，这种方案没有实现;二是在Java层或者JNI层修改，使其线程安全。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  JNI编程和Linux上的C/C++编程还是挺相似的，每次java调用JNI中的函数时都会传入有关JVM的一些参数（如JNIEnv，jobject），每次JNI回调java中的方法时都要通过JVM的有关参数来实现，当在JNI中涉及到多线程的话还是有一些不一样的地方，就是要在子线程函数里使用AttachCurrentThread()和DetachCurrentThread()这两个函数，在这两个函数之间加入回调java方法所需要的代码。</p><p>  JNIEnv是一个线程相关的变量,JNIEnv 对于每个 thread 而言是唯一的,JNIEnv *env指针不可以为多个线程共用。但是Java虚拟机的JavaVM指针是整个jvm公用的，我们可以通过JavaVM来得到当前线程的JNIEnv指针。可以使用javaAttachThread保证取得当前线程的Jni环境变量。</p><h2 id="native层修改"><a href="#native层修改" class="headerlink" title="native层修改"></a>native层修改</h2><ol><li>保存全局的JavaVM指针</li></ol><figure class="highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function">jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-keyword">void</span>* reserved)</span> </span>&#123;<br>    ...<br>    <br>    <span class="hljs-comment">//将vm指针保存到全局变量中</span><br>    set_jvm(vm);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>Lua运行时获取当前线程的env</li></ol><p>在 luajava.c的getEnvFromState方法实现里，去更新指针。</p><figure class="highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function">JNIEnv *<span class="hljs-title">getEnvFromState</span><span class="hljs-params">(lua_State *L)</span> </span>&#123;<br><br>    JNIEnv *javaEnv = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (g_jvm-&gt;AttachCurrentThread(&amp;javaEnv, <span class="hljs-literal">NULL</span>) == JNI_OK) &#123;<br>        <span class="hljs-keyword">return</span> javaEnv;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        LOGE(<span class="hljs-string">"JavaEnv attach failed!"</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java层修改"><a href="#Java层修改" class="headerlink" title="Java层修改"></a>Java层修改</h2><ol start="3"><li>去除同步锁</li></ol><p>在<a href="https://github.com/jasonsantos/luajava/blob/b27d23db7d3b701931ac96740b5a9b05be8d240b/src/java/org/keplerproject/luajava/Console.java#L84" target="_blank" rel="noopener">Console.java</a>中，去除掉pcall的synchronized，否则在整个脚本运行期间，pcall会持续占有luastate的锁，导致其他线程无法获得同步锁，所以无法调用luastate的其他方法。</p><p>这里并不是说完全去除掉同步锁，而是只需要在多线程操作的地方，局部同步LuaState，否则LuaVM栈可能会出错。</p><ol start="4"><li>在 JavaFunction 类，删除掉LuaState L，用全局ThreadLocal来代替存储。</li></ol><p>execute稍作修改，让native调用的时候调的是execute(long)方法，这样在方法执行之前可以做一些事情。</p><figure class="highlight Java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs Java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaFunction</span> </span>&#123;<br><br>    <span class="hljs-comment">/**<br>     * This is the state in which this function will exist.<br>     */</span><br>    <span class="hljs-comment">//    protected LuaState L;</span><br>    <span class="hljs-comment">//用来保存c层lua_state的指针，当需要在对应栈上操作的时候，从这个ThreadLocal取</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Long&gt; mLuaStateCPoniter = <span class="hljs-keyword">new</span> ThreadLocal&lt;Long&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">long</span>) <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">/**<br>     * This method is called from Lua. Any parameters can be taken with<br>     * &lt;code&gt;getParam&lt;/code&gt;. A reference to the JavaFunctionWrapper itself is<br>     * always the first parameter received. Values passed back as results<br>     * of the function must be pushed onto the stack.<br>     *<br>     * <span class="hljs-doctag">@return</span> The number of values pushed onto the stack.<br>     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LuaException</span>;<br><br>    <span class="hljs-comment">//native调用这个同步的execute，保证在正确的栈上调用完后才能让其他线程换栈</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lua_state)</span> <span class="hljs-keyword">throws</span> LuaException </span>&#123;<br>        mLuaStateCPoniter.set(lua_state);<br>        <span class="hljs-keyword">return</span> execute();<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * Constructor that receives a LuaState.<br>     *<br>     * <span class="hljs-doctag">@param</span> L LuaState object associated with this JavaFunction object<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaFunction</span><span class="hljs-params">(LuaState L)</span> </span>&#123;<br>        mLuaStateCPoniter.set(L.getCPtrPeer());<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * Returns a parameter received from Lua. Parameters are numbered from 1.<br>     * A reference to the JavaFunction itself is always the first parameter<br>     * received (the same as &lt;code&gt;this&lt;/code&gt;).<br>     *<br>     * <span class="hljs-doctag">@param</span> idx Index of the parameter.<br>     * <span class="hljs-doctag">@return</span> Reference to parameter.<br>     * <span class="hljs-doctag">@see</span> LuaObject<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LuaObject <span class="hljs-title">getParam</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> luaStateCPoniter = mLuaStateCPoniter.get();<br>        LuaState L = LuaStateFactory.getExistingState(luaStateCPoniter);<br>        <span class="hljs-keyword">return</span> L.getLuaObject(idx);<br>    &#125;<br><br>    <span class="hljs-comment">/**<br>     * Register a JavaFunction with a given name. This method registers in a<br>     * global variable the JavaFunction specified.<br>     *<br>     * <span class="hljs-doctag">@param</span> name name of the function.<br>     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> LuaException </span>&#123;<br>        <span class="hljs-keyword">long</span> luaStateCPoniter = mLuaStateCPoniter.get();<br>        <span class="hljs-comment">//新增的方法，用于获取当前线程的LuaState</span><br>        LuaState L = LuaStateFactory.getExistingState(luaStateCPoniter);<br>        <span class="hljs-keyword">synchronized</span> (L) &#123;<br>            L.pushJavaFunction(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//在栈上生成一个userdata，并设置其metatable的一些方法</span><br>            L.setGlobal(name);<span class="hljs-comment">//然后将这个userdata存在global表上</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>LuaStateFatcoty新增一个方法，根据当前的CPointer获取对应的LuaState。</li></ol><figure class="highlight Java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**<br> * Returns a existing instance of LuaState<br> *<br> * <span class="hljs-doctag">@param</span> cPointer<br> * <span class="hljs-doctag">@return</span> LuaState<br> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> LuaState <span class="hljs-title">getExistingState</span><span class="hljs-params">(<span class="hljs-keyword">long</span> cPointer)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(Object luaState:states)&#123;<br>        <span class="hljs-keyword">if</span>(luaState!=<span class="hljs-keyword">null</span>)&#123;<br>            LuaState lua_state = (LuaState)luaState;<br>            <span class="hljs-keyword">if</span>(lua_state.getCPtrPeer() == cPointer)&#123;<br>                <span class="hljs-keyword">return</span> lua_state;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这种实现方式有点类似于协程，魔改之后算是基本能支持多线程操作，虽然不是很完美也可能不太稳定。这个多线程方案在产品中调用频次很低，所以也没有反馈实际效果如何，但是至少不崩溃并且异步回调是正常的。</p><p>因为Lua虚拟机本身就是只能单线程执行的，强行使其多线程执行肯定会有一些问题，除非有人有能力修改Lua的虚拟机那也是不错的。</p>]]></content>
    
    
    <categories>
      
      <category>游戏助手</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>LuaJava</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小记Java内存回收</title>
    <link href="/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    <url>/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<p>Java GC（Garbage Collection，GC），就是释放垃圾占用的内存空间，防止内存泄露。</p><p><img src="%E5%8F%AF%E5%9B%9E%E6%94%B6%E5%9E%83%E5%9C%BE.jpg" srcset="/img/loading.gif" alt="可回收垃圾.jpg"></p><h1 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h1><p>判断内存对象是否能被回收主要有两种方法：</p><ul><li>引用计数法（Reachability Counting）</li><li>可达性分析算法（Reachability Analysis）</li></ul><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>引用计数法是最简单的，在分配对象的时候，记录该对象当前的被引用次数 RC ，当有其他对象引用该对象的时候 RC 加1，解除引用的时候减1，当 RC 为0的时候就会被回收调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符串"gc"被s引用</span><br>String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"gc"</span>);<br><br><span class="hljs-comment">//释放引用， 字符串"gc"被回收</span><br>s = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><p>优点：</p><ol><li><p>可立即回收。每个对象都知道自己的引用计数，当变为0时可以立即回收，将自己接到空闲链表</p></li><li><p>GC暂停时间短。应用更新指针的时候就可以执行垃圾回收，开销分摊到整个生命周期，不需要挂起整个应用的运行直到堆中所有对象都处理结束（Stop-The-World）。</p></li></ol><p>缺点：</p><ol><li><p>计数器值的增减处理频繁。每次对象更新都需要对计数器进行增减，特别是被引用次数多的对象。</p></li><li><p>计数器需要占用很多位。计数器的值最大必须要能数完堆中所有对象的引用数。</p></li><li><p><strong>循环引用无法回收</strong>。</p></li></ol><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>可达性分析法解决了循环依赖的问题，基本思路是构建一系列的 GC 树，从根节点 GC Root 开始搜索，当对象不在任何一个 GC 树上的就属于可回收垃圾。</p><p><img src="%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="可达性分析法.jpeg"></p><h3 id="GC-Root根节点的选择"><a href="#GC-Root根节点的选择" class="headerlink" title="GC Root根节点的选择"></a>GC Root根节点的选择</h3><p>在 Java 中，可作为 GC Root 的对象包括以下4种：</p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</p></li></ul><h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><p>确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收。</p><h2 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h2><p>标记清除法最快最简单，直接回收被标记的垃圾。</p><p>缺点：</p><p>产生大量的内存碎片，内存利用率低。</p><p><img src="%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="标记清除法.jpeg"></p><h2 id="复制法"><a href="#复制法" class="headerlink" title="复制法"></a>复制法</h2><p>复制法将内存区域划分成两等分，每次只使用一份，回收垃圾的时候将存活的对象复制到另一边，然后清理掉这块内存。</p><p>优点：</p><p>速度快，避免内存碎片</p><p>缺点：</p><p>内存利用率不高，只能使用一半的内存</p><p><img src="%E5%A4%8D%E5%88%B6%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="复制法.jpeg"></p><h2 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h2><p>标记清除法的升级版，在清除完标记的垃圾之后，存活的对象整理向一边移动，留出更大的内存区域。</p><p>优点：</p><p>避免内存碎片，内存利用率高</p><p>缺点：</p><p>内存变动频繁效率低速度慢</p><p><img src="%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="标记整理法.jpeg"></p><h2 id="分代回收法"><a href="#分代回收法" class="headerlink" title="分代回收法"></a>分代回收法</h2><p>分代回收算法综合了上面几种方法的优点，根据不同场景使用不同的方法。</p><p>该方法主要将内存分为新生代区和老年代区（Old），新生代区由Eden区和Survivor区组成，其中Survivor区又分为From和To区。</p><p><img src="%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B3%95.jpeg" srcset="/img/loading.gif" alt="分代回收法.jpeg"></p><h3 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h3><p>大多数对象消亡速度都很快，所以大部分内存都在Eden区进行分配。</p><p>在Eden区进行的GC被称作（<strong>Minor GC</strong>），速度很快，每次Minor GC后基本会清空Eden区，剩余存活的对象会进入Survivor的From区，如果From区不够大会直接进入到Old区。</p><h3 id="Survivor区"><a href="#Survivor区" class="headerlink" title="Survivor区"></a>Survivor区</h3><p>Survivor区相当于Eden和Old的缓冲区，因为Eden 的 Minor GC 速度快，避免太多对象太快进入Old区。</p><p>每一次Minor GC ， Survivor 的 From 和 To 区就会进行<strong>复制回收</strong>，Survivor 中存活的对象年龄增加，直到达成年后（16岁或动态阈值）被送往Old区。</p><h3 id="Old区"><a href="#Old区" class="headerlink" title="Old区"></a>Old区</h3><p>Old区占用大部分内存空间，每次GC都会触发Stop-The-World，也叫 <strong>Major GC</strong> ，频率会比 Minor GC 要低。</p><p>因为Old区存活对象多，如果用复制法会操作很多次内存效率和空间利用率都低，所以在Old区折中使用<strong>标记整理法</strong>来进行回收。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://yq.aliyun.com/articles/708634" target="_blank" rel="noopener">咱们从头到尾说一次 Java 垃圾回收</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
      <tag>垃圾回收</tag>
      
      <tag>内存</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LuaJava在Java、Android中的使用</title>
    <link href="/2017/10/08/LuaJava%E5%9C%A8Java%E3%80%81Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2017/10/08/LuaJava%E5%9C%A8Java%E3%80%81Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>最近公司在做一个项目，需要用Lua语言编写的脚本来动态控制安卓app的行为。  </p><p>项目涉及到Lua、LuaJava框架和安卓native开发等知识点。本文主要介绍Lua和Java语言之间是怎么相互调用的，并记录一些开发过程中碰到的问题。</p><h2 id="Lua一些概念"><a href="#Lua一些概念" class="headerlink" title="Lua一些概念"></a>Lua一些概念</h2><blockquote><p>Lua是一门扩展式程序设计语言，被设计成支持通用过程式编程，并有相关数据描述设施。同时对面向对象编程、函数式编程和数据驱动式编程也提供了良好的支持。 </p></blockquote><p>概念的东西简单看一下就行，总结来说Lua是一种轻量的语言，并且支持多重编程范式，可以任意地对语言进行自需的改造。</p><blockquote><p>作为一门扩展式语言，Lua没有”main”程序的概念：它只能嵌入一个宿主程序中工作，该宿主程序被称为被嵌入程序或者简称宿主。宿主程序可以调用函数执行一小段Lua代码，可以读写Lua变量，可以注册C函数让Lua代码调用。</p></blockquote><p>Lua程序一般不单独运行，虽然也可以但是能做的事情就比较简单。标准的<a href="https://www.lua.org/download.html" target="_blank" rel="noopener">Lua虚拟机</a>通过C语言编写的，一般是通过C\C++来拓展Lua的函数，这样接口兼容速度更快。  </p><p>这里重点记录一下Lua的栈，方便后面进行描述。</p><p>Lua虚拟机与C/C++之间的数据交换基本都是通过Lua构建虚拟<a href="https://cloudwu.github.io/lua53doc/manual.html#4.1" target="_blank" rel="noopener"><strong>栈</strong></a>来交互的，无论何时Lua调用 C，被调用的函数都得到一个新的栈， 这个栈独立于C函数本身的栈，也独立于之前的 Lua 栈。它里面包含了Lua传递给C函数的所有参数，而C函数则把要返回的结果放入这个栈以返回给调用者这里。</p><html><img src="Lua栈模型.png" srcset="/img/loading.gif" alt="Lua栈模型"/></html><p>如图Lua的栈的访问索引分为正索引和负索引。正的索引指的是栈上的绝对位置（从1开始）；负的索引则指从栈顶开始的偏移量。展开来说，如果堆栈有 n 个元素，那么索引 1 表示第一个元素（也就是最先被压栈的元素）而索引 n 则指最后一个元素；索引 -1 也是指最后一个元素（即栈顶的元素），索引 -n 是指第一个元素。</p><h2 id="用自定义C函数拓展Lua虚拟机"><a href="#用自定义C函数拓展Lua虚拟机" class="headerlink" title="用自定义C函数拓展Lua虚拟机"></a>用自定义C函数拓展Lua虚拟机</h2><p>自定义的C函数必须得符合Lua定义的方法签名：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef int (*lua_CFunction) (lua_State *<span class="hljs-type">L</span>)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span> <span class="hljs-params">(lua_State *L)</span> </span>&#123;<br>    ...<br>    <span class="hljs-comment">// func body</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>Lua虚拟机调用函数时，C函数通过Lua中的栈来接受参数，参数以正序入栈（第一个参数首先入栈），当需要向Lua返回值的时候，C函数只需要把它们以正序压到堆栈上（第一个返回值最先压入），然后返回这些返回值的个数。  </p><p>这么说还比较抽象还是具体举例子来说明，下面假设实现一个函数需要能够同时计算输入参数的平均值与和，然后将两个值返回给Lua层。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">int</span> foo (lua_State *L) &#123;<br><br>      <span class="hljs-keyword">int</span> n = lua_gettop(L);    <span class="hljs-comment">/* 得到参数参数的个数 */</span><br>      lua_Number <span class="hljs-keyword">sum</span> = <span class="hljs-number">0.0</span>;<br>      <span class="hljs-keyword">int</span> i;<br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">sum</span> += lua_tonumber(L, i);<br>      &#125;<br>      lua_pushnumber(L, <span class="hljs-keyword">sum</span>/n);        <span class="hljs-comment">/* 第一个返回值 */</span><br>      lua_pushnumber(L, <span class="hljs-keyword">sum</span>);         <span class="hljs-comment">/* 第二个返回值 */</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;                   <span class="hljs-comment">/* 返回值的个数 */</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>其中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> n = lua<span class="hljs-constructor">_gettop(L)</span>;    <span class="hljs-comment">/* 得到参数参数的个数 */</span><br></code></pre></td></tr></table></figure><p>lua_gettop()函数可以得到栈顶元素的索引。因为索引是从1开始编号的,所以这个结果等于栈上的元素个数。特别指出，0表示栈为空。当然这里也可以调用</p><blockquote><p>lua_Number lua_tonumberx (lua_State <em>L, int index, int</em>isnum); 把给定索引处的 Lua 值转换为 lua_Number 这样一个 C 类型</p></blockquote><p>来直接得到指定索引的值。  </p><p>定义好c函数后，需要将其注册到Lua的虚拟机中才能被调用。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lua_State *L = luaL_newstate();<br>luaL_openlibs(L); <span class="hljs-comment">//初始化一些自己的东西</span><br> <span class="hljs-comment">// 传入任意的函数名和函数的指针作为参数</span><br>lua_register(L, “foo<span class="hljs-string">", foo);</span><br> <span class="hljs-comment">// 加载运行Lua脚本</span><br>luaL_dofile(L,<span class="hljs-string">"test.lua"</span>);<br></code></pre></td></tr></table></figure><p>这里lua_register是一个宏定义，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define lua<span class="hljs-constructor">_register(L,<span class="hljs-params">n</span>,<span class="hljs-params">f</span>)</span> \<br>            (lua<span class="hljs-constructor">_pushcfunction(L, <span class="hljs-params">f</span>)</span>, lua<span class="hljs-constructor">_setglobal(L, <span class="hljs-params">n</span>)</span>)<br></code></pre></td></tr></table></figure><p>它的作用把 C 函数 f 设到全局变量 name 中，这样Lua就可以访问这个变量<a href="https://cloudwu.github.io/lua53doc/manual.html#2.4" target="_blank" rel="noopener"><strong>元表</strong></a>对应的call方法作为函数来调用。  </p><p>最后来写个测试demo来测试一下我们的自定义函数：</p><p><strong>test.lua:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br>    ret1, ret2 = foo(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>    <span class="hljs-built_in">print</span> ret1<br>    <span class="hljs-built_in">print</span> ret2<br><span class="hljs-keyword">end</span><br><br>test()<br></code></pre></td></tr></table></figure><p><strong>得到的结果为</strong>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&gt; <span class="hljs-number">2.5</span><br>&gt; <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>So easy~</p><h2 id="Java与Lua之间的交互方式"><a href="#Java与Lua之间的交互方式" class="headerlink" title="Java与Lua之间的交互方式"></a>Java与Lua之间的交互方式</h2><p>基于上述Lua这种”寄生工作”的特性，Java与Lua语言之间相互调用的思路已经很明显了，就是以JNI作为中介。</p><p><strong>通过Native调用Lua：</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl">graph TD<br>J<span class="hljs-function"><span class="hljs-title">ava</span>--&gt;</span>Native<br>N<span class="hljs-function"><span class="hljs-title">ative</span>--&gt;</span>LuaVM<br></code></pre></td></tr></table></figure><p>以前的做法是先用C/C++借助JNI编写调用Java的接口函数，然后再将这些函数通过 <a href="https://github.com/LuaDist/toluapp" target="_blank" rel="noopener">tolua++</a>工具导出给Lua使用。这种做法最大的问题就是太繁琐，而且稍微有一点点修改，就要重新编译，严重降低了开发效率。  </p><p>这里我们可以借助一些框架，也就是Lua和Java之间的“桥梁”来省掉不必要的工作，例如：</p><ul><li><a href="http://www.luaj.org/luaj/3.0/README.html" target="_blank" rel="noopener">LuaJ</a></li><li><a href="https://github.com/jasonsantos/luajava" target="_blank" rel="noopener">LuaJava</a></li><li><a href="https://www.kahlua.com/" target="_blank" rel="noopener">kahlua</a>  </li></ul><p>还有不知名的mochalua，jill等就不贴出来了。  </p><p>首先LuaJ框架是使用纯Java语言来实现的，它用Java实现了一套自己的Lua虚拟机，所以就不需要JNI来做中介了，所以对于多年不接触C/C++代码的人来看会更加舒服一些。并且该框架还在更新维护，接口用起来更加方便，但是缺点在于纯Java实现，相对C语言实现<strong>速度慢</strong>。    </p><p>LuaJava框架就比上一个轻量一些，是基于Lua原生的虚拟机进行开发的，它只对标准的Lua编程API做了简单的JNI封装，Java层的代码也较少。这个框架虽然已经停止维护，但还是能支持最新的Lua5.3版本。  </p><p>我们开发的项目最后采用的是LuaJava框架，后文也将会对该框架进行解析。  </p><h2 id="用自定义Java函数拓展Lua虚拟机"><a href="#用自定义Java函数拓展Lua虚拟机" class="headerlink" title="用自定义Java函数拓展Lua虚拟机"></a>用自定义Java函数拓展Lua虚拟机</h2><p>LuaJava框架主要是对Lua的编程接口进行简单的封装，并且提供一些方便Lua、Java函数相互调用的接口，节省了自己去写JNI转换代码的功夫。后续会具体解析这个框架是怎么实现这部分的。</p><html><img src=".pngLuaJava框架的作用" srcset="/img/loading.gif" alt="LuaJava框架的作用" /></html>  <p>这里要使用自定义的Java函数来拓展Lua虚拟机需要以下几步：</p><ol><li>继承实现抽象类JavaFunction，实现自定义函数内容；</li><li>调用注册方法注册函数到虚拟机；</li><li>编写Lua脚本调用函数运行。  </li></ol><p>先看看JavaFunction类有什么方法，</p><html><img src="JavaFunction类图.png" srcset="/img/loading.gif" alt="JavaFunction类图" /></html><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">L:</span> Luastate<br></code></pre></td></tr></table></figure><p>Lua虚拟机的Java层访问接口，记录CLuaSate在C层的指针地址。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">excute</span><span class="hljs-params">()</span></span>: int<br></code></pre></td></tr></table></figure><p>自定函数执行入口方法，这是一个需要自己实现的抽象方法，参数的获取和返回值的传递都在这里完成，其中返回的int型代表了返回给Lua结果的个数，与上面C方法是类似的。  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">get<span class="hljs-constructor">Param(<span class="hljs-params">index</span>:<span class="hljs-params">int</span>)</span> : LuaObject<br></code></pre></td></tr></table></figure><p>获取Lua参数。在C层获取参数的index是从1开始的拿到函数的第一个参数，但是在这个LuaJava框架里你需要<strong>从2开始获得第一个参数</strong>，这是框架的一个小坑后面会讲到。  </p><p> LuaObject就是Lua对象在Java层的一个表示，实际上这个Object只维护了指向Lua注册表对应对象的一个引用，这里用到了<strong>Lua的引用机制</strong>的知识。  </p><blockquote><p>Lua 提供了一个 注册表， 这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。 这个表可以用有效伪索引 LUA_REGISTRYINDEX 来定位。 任何 C 库都可以在这张表里保存数据， 为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名， 或者取你自己 C 对象的地址，以轻量用户数据的形式做键， 还可以用你的代码创建出来的任意 Lua 对象做键。 关于变量名，字符串键名中以下划线加大写字母的名字被 Lua 保留。<br>注册表中的整数键用于引用机制（参见luaL_ref），以及一些预定义的值。因此，整数键不要用于别的目的。  </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">register</span>(funcName : <span class="hljs-built_in">string</span>) : <span class="hljs-keyword">void</span><br></code></pre></td></tr></table></figure><p>注册函数到Lua虚拟机。编写好具体Java类后只需要调用该父类方法，传入你的自定义函数名称就ok了！  </p><p>下面还是具体来讲个例子。这个自定义函数实现一个打印Log内容，最后返回一个boolean值的功能。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class TestLog extends JavaFunction&#123;<br>  …<br>   @Override<br>   public <span class="hljs-built_in">int</span> execute<span class="hljs-literal">()</span> throws LuaException &#123;<br>        LuaObject paramObj = get<span class="hljs-constructor">Param(2)</span>; <span class="hljs-comment">//获取Log参数</span><br>        String logContent = paramObj.get<span class="hljs-constructor">String()</span>;<span class="hljs-comment">//将C对象转换成Java对象</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(<span class="hljs-string">"[testLog]"</span>, logContent);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>push<span class="hljs-constructor">Boolean(<span class="hljs-params">true</span>)</span>;<span class="hljs-comment">//传递返回值</span><br>        return <span class="hljs-number">1</span>;<br>   &#125;<br>   …<br>&#125;<br></code></pre></td></tr></table></figure><p>编写好自定义函数之后，初始化LuaState，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">LuaState L = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LuaStateFactory</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">LuaState()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">Libs()</span>;<br></code></pre></td></tr></table></figure><p>最后注册函数，编写我们的测试用例即可，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*注册函数，对应Lua函数名为testLog*/</span><br><span class="hljs-selector-tag">testFunc</span><span class="hljs-selector-class">.register</span>(“<span class="hljs-selector-tag">testLog</span>“);<br><br><span class="hljs-comment">/*载入并运行lua脚本文件*/</span><br><span class="hljs-selector-tag">L</span><span class="hljs-selector-class">.LdoFile</span>(“<span class="hljs-selector-tag">test</span><span class="hljs-selector-class">.lua</span>”);<br></code></pre></td></tr></table></figure><p>测试代码test.lua：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">"os"</span>)</span><br><span class="hljs-variable">function</span> <span class="hljs-function"><span class="hljs-title">tlog</span>(<span class="hljs-variable">content</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">testLog</span>(<span class="hljs-variable">content</span>)</span><br><span class="hljs-variable">end</span><br><br><span class="hljs-function"><span class="hljs-title">tlog</span>(<span class="hljs-string">"abc"</span>)</span><br><span class="hljs-function"><span class="hljs-title">tlog</span>(<span class="hljs-string">"time"</span>..os.time)</span><br></code></pre></td></tr></table></figure><p>得到期望的输出结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; abc</span><br><span class="hljs-quote">&gt; 1494843227</span><br></code></pre></td></tr></table></figure><h2 id="LuaJava框架的工作原理"><a href="#LuaJava框架的工作原理" class="headerlink" title="LuaJava框架的工作原理"></a>LuaJava框架的工作原理</h2><p>上面说到我们需要调用注册方法register来注册自定义Java函数，查看其源码发现和C代码的实现是一样的，也是拆分成了两个步骤：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void register(String name )&#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>push<span class="hljs-constructor">JavaFunction(<span class="hljs-params">this</span>)</span>; <span class="hljs-comment">// 先将函数对象压入栈</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>set<span class="hljs-constructor">Global(<span class="hljs-params">name</span>)</span>; <span class="hljs-comment">//将该对象设置为全局变量来使用</span><br>     &#125;<br></code></pre></td></tr></table></figure><p>第一步将Java对象压栈，Java部分没有什么代码，直接是调用了对应的native方法，jni_pushJavaFunction 来工作，看一下具体实现代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void  jni_pushJavaFunction ( … )<br>&#123;<span class="hljs-operator"><br>    ...<br>    </span>...<br>   userData = ( jobject<span class="hljs-operator"> * </span>) lua<span class="hljs-constructor">_newuserdata( L , <span class="hljs-params">sizeof</span>( <span class="hljs-params">jobject</span> )</span> ); <span class="hljs-comment">// 分配一块指定大小的内存块， 把内存块地址作为一个完全用户数据压栈</span><br>   *userData = javaFunctionObjRef; <span class="hljs-comment">// 用户空间存放一个指针即轻量用户数据</span><br>   <br>   lua<span class="hljs-constructor">_newtable( L )</span>; <span class="hljs-comment">// 创建一个新表</span><br><br>   lua<span class="hljs-constructor">_pushstring( L , LUACALLMETAMETHODTAG )</span>;  <br>    <br>   lua<span class="hljs-constructor">_pushcfunction( L , &amp;<span class="hljs-params">luaJavaFunctionCall</span> )</span>; <span class="hljs-comment">// 将调用函数加入table中</span><br><br>   lua<span class="hljs-constructor">_rawset( L , -3 )</span>;  <span class="hljs-comment">// rawset 不会触发元方法避免调用到其他元操作</span><span class="hljs-operator"><br>   ...<br><br>  </span><span class="hljs-keyword">if</span> ( lua<span class="hljs-constructor">_setmetatable( L , -2 )</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span> )   <span class="hljs-comment">// 将该table作为userData的元表  </span><br>    &#123;<span class="hljs-operator"><br>      ...   </span><span class="hljs-comment">//抛出JNI异常</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>首先创建一块Lua的Userdata数据类型，</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">userData</span> = ( jobject * ) lua_newuserdata( L , sizeof( jobject ) )<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个userdata其实就是分配出一块jobject大小内存，用来记录对应的函数指针地址即通过JNI传来的javaFunctionObjRef，L是C层的LuaState指针。  </p><p>接下来需要创建该userdata的元表（metadata），还不清楚元表概念的返回去查手册看看就行，</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">lua_pushstring( <span class="hljs-name">L</span> , LUACALLMETAMETHODTAG )<span class="hljs-comment">;  </span><br>lua_pushcfunction( <span class="hljs-name">L</span> , <span class="hljs-symbol">&amp;luaJavaFunctionCall</span> )<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这里将元表函数调用的常量标识LUACALLMETAMETHODTAG压入栈作为key，把一个叫做luaJavaFunctionCall函数的地址作为value，这样Lua以函数的方式调用这块userdata的时候就可以从元表查到这个函数地址并调用。  </p><p>最后回到Java层，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">L</span>.</span></span>set<span class="hljs-constructor">Global(<span class="hljs-params">name</span>)</span>;<br></code></pre></td></tr></table></figure><p>将这一个userdata设置为一个全局变量，Lua脚本在运行时候就能正常操作这个变量了。</p><p>所以这个luaJavaFunctionCall函数就是自定义函数被Lua脚本调用到时，真正工作的地方，其实对应实现在C层：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span>  lua<span class="hljs-constructor">JavaFunctionCall( <span class="hljs-params">lua_State</span> <span class="hljs-operator">*</span> L )</span><br>&#123;<span class="hljs-operator"><br>  ...<br>  </span>...<br> obj = lua<span class="hljs-constructor">_touserdata( L , 1 )</span>; <span class="hljs-comment">// 这个obj其实就是之前记录的函数引用地址</span><br> javaEnv = get<span class="hljs-constructor">EnvFromState( L )</span>; <span class="hljs-comment">//转换成userdata格式，从LuaState中读取出JNIEnv，</span><span class="hljs-operator"><br> ...<br>  </span>ret = ( *javaEnv )-&gt;<span class="hljs-constructor">CallIntMethod( <span class="hljs-params">javaEnv</span> , <span class="hljs-operator">*</span><span class="hljs-params">obj</span> , <span class="hljs-params">java_function_method</span> )</span>; <span class="hljs-comment">// 回调execute</span><span class="hljs-operator"><br>   ... <br>  </span>return ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里在回去看看前面的JavaFunction.java类，就基本明白是怎么回事了。首先从函数栈中取出第一个参数（这里参考前面的自定义C函数部分），就是前面我们创建的userdata，是自定义JavaFunction类的指针，前面说到有一个坑点就在这里，JavaFUntion类的获取参数为什么要从index=2开始，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">get<span class="hljs-constructor">Param(<span class="hljs-params">index</span>:<span class="hljs-params">int</span>)</span> : LuaObject<br></code></pre></td></tr></table></figure><p>因为第一个参数是我们的userdata本身，第二个开始才是正确的函数参数。<br>最后很简单了，通过jni反射调用Java层的execute方法（java_function_method）执行Java层的工作。<br>也是So easy！</p><p>到此完成一次完整的使用Java函数拓展Lua虚拟机的过程。这种方法和用C语言来拓展方式不太一样的地方，就是userdata和元表，获取参数的顺序也不太一样，再往深入的虚拟机里面的实现也还没来得及看，以后有时间的话再继续研究研究。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这个Luajava框架其实坑点和问题其实还是很多的，并不能完善的上线，例如无法中断停止脚本、多线程问题和JavaGC超时异常等等问题也是头疼，但是经过本人的优化修改都已经把这些问题解决了~后续会继续写文记录一下。<br>One more，如果有能力和时间其实还是不建议使用这个框架了，太麻烦性能也不是特别好，自己从0搞一个。</p><p>这篇文章挖坑了好久，终于趁着放假填完了哈哈哈，之前这个新产品赶着上线事情太多了~</p>]]></content>
    
    
    <categories>
      
      <category>游戏助手</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LUA</tag>
      
      <tag>JAVA</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
