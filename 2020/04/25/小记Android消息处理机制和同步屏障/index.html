<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="hoholiday">
  <meta name="keywords" content="">
  <title>小记Android消息处理机制和同步屏障 - hohliday&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_9n5xqdrq0nc.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>hohliday's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              归档</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              分类</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              标签</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-04-25 18:56">
                    星期六, 四月 25日 2020, 6:56 晚上
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    2.4k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    33
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>代码版本： <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30" target="_blank" rel="noopener">Android-10.0.0_r30</a></p>
<h1 id="消息处理架构"><a href="#消息处理架构" class="headerlink" title="消息处理架构"></a>消息处理架构</h1><p>在Java层上，Android实现消息处理机制主要有以下几个类：</p>
<ul>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Handler.java" target="_blank" rel="noopener">android/os/Handler.java</a></li>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Message.java" target="_blank" rel="noopener">android/os/Message.java</a></li>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Looper.java" target="_blank" rel="noopener">android/os/Looper.java</a></li>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="noopener">android/os/MessageQueue.java</a></li>
</ul>
<p>虽然它们之间的关系比较简单，但如果要深究其原理还是非常复杂的，特别是到native层部分。</p>
<p><img src="%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%9E%B6%E6%9E%84.png" srcset="/img/loading.gif" alt="消息机制架构.png"></p>
<p>如图所示，Handler负责处理消息，类似一个句柄，其他线程可以向其发送 Message ， Message 进入消息队列 MessageQueue 中，一个运行在主线程的 Looper 不断从队列中取出消息，然后调用其 Handler 或者 Callback 处理逻辑。</p>
<h1 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h1><h2 id="构建Looper"><a href="#构建Looper" class="headerlink" title="构建Looper"></a>构建Looper</h2><p>Looper 的内部维护了一个 MessageQueue 对象，在线程中调用 Looper.prepare 来创建新的 Looper。</p>
<pre><code class="java">class LooperThread extends Thread {
      Handler handler;
      public void run() {
          // 必须先调用
          Looper.prepare();
          //用 Looper 来创建 Handler
          handler = new Handler(Looper.myLooper());
          Looper.loop();
      }
 }</code></pre>
<p>Looper#prepare 方法里，构建一个新的 Looper 对象，然后将其放入静态的<br> sThreadLocal 中。</p>
<blockquote>
<p>ThreadLocal: This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. </p>
</blockquote>
<p>如果重复调用 prepare 会抛出异常，所以<strong>每个线程只能有一个 Looper</strong>。</p>
<p>在主线程（UI Thread）中不需要创建 Looper，因为在应用 ActivityThread 创建出来的时候，在 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/app/ActivityThread.java;l=7329;drc=0a9ee1af2cba8da1de3aace999d8547503c06f4c" target="_blank" rel="noopener">main</a> 方法中已经调用过 Looper#prepareMainLooper 了。</p>
<pre><code class="java">private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }</code></pre>
<p>最后调用 Looper#loop 方法，创建一个 MessageQueue 并循环等待调用其 next 方法得到下一条要被处理的消息，将这个消息分发给对应的处理者。</p>
<pre><code class="java">public static void loop() {
        final Looper me = myLooper();
        ...
        final MessageQueue queue = me.mQueue;
        ...
        for (;;) {
            Message msg = queue.next(); // might block
            ...
            // 分发事件给 target 处理，也就是消息对应的 Handler
            msg.target.dispatchMessage(msg); 
            ...
            // 回收 Message
            msg.recycleUnchecked();
        }
        ...
}</code></pre>
<p>到这里Looper 的主要工作就结束了。</p>
<h2 id="构建Handler"><a href="#构建Handler" class="headerlink" title="构建Handler"></a>构建Handler</h2><p>Handler 的构建必须依赖 Looper 作为参数，否则就是无效 Handler，即使在主线程创建，Google 官方还是推荐使用以 Looper 作为参数的构建方式来创建 Handler，</p>
<pre><code class="java">Handler h = new Handler(Looper.getMainLooper());</code></pre>
<p>在新版的代码中可以看到，Handler 的无参构建方法已经标记为 Deprecated 了，目的是避免错误隐患和保证代码可读性。</p>
<p>Handler 还有几个被 hide 的构造方法，和异步消息有关，后续继续分析。</p>
<pre><code class="java">    /**
    * @hide
    */
    public Handler(boolean async) {
        this(null, async);
    }</code></pre>
<h2 id="Handler-处理消息"><a href="#Handler-处理消息" class="headerlink" title="Handler 处理消息"></a>Handler 处理消息</h2><p>Handler 的 dispatchMessage 方法负责接收 Looper 分发的消息，可以看到消息处理的优先级：</p>
<p>Message 内的 callback &gt; Handler 的 callback &gt; handleMessage 方法</p>
<pre><code class="java"> public void dispatchMessage(@NonNull Message msg) {
        if (msg.callback != null) {
            handleCallback(msg); // 1
        } else {
            if (mCallback != null) {
                // 2
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg); // 3
        }
    }</code></pre>
<h1 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h1><h2 id="构造-Message"><a href="#构造-Message" class="headerlink" title="构造 Message"></a>构造 Message</h2><p>构造一个 Message 对象可以直接 new 一个出来，但是一般都使用 Message.obtain() 从对象池中获取，否则如果消息频率太高会导致短时间内存占用上升，虚拟机频繁 <a href="https://hoholidayx.github.io/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B3%95">GC</a>  影响性能。</p>
<p>Message 其实是链表结构，</p>
<pre><code class="java">public final class Message implements Parcelable {
    ...
    public int what;
    ...
    // sometimes we store linked lists of these things
    /*package*/ Message next;
    ...
    // 对象池起始当前节点
    private static Message sPool;
}</code></pre>
<p>使用一个静态 sPool 变量表示当前对象池链表的头节点，通过 obtain 方法获取 Message 的时候把头结点从链表移除。</p>
<pre><code class="java">    public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool;
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }</code></pre>
<p>Message 使用完后调用 recycle 方法进入 recycleUncheckd ，将当前Message插入回链表头部。</p>
<pre><code class="java">            if (sPoolSize &lt; MAX_POOL_SIZE) {
                next = sPool;
                sPool = this;
                sPoolSize++;
            }</code></pre>
<p>所以实际上这个对象池是一个用链表实现的栈。</p>
<h2 id="通过-Handler-发送-Message"><a href="#通过-Handler-发送-Message" class="headerlink" title="通过 Handler 发送 Message"></a>通过 Handler 发送 Message</h2><p>调用 Handler 的 sendMessage 方法，最后到 sendMessageAtTime 中，向 MessageQueue 入队消息。</p>
<pre><code class="java"> private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
            long uptimeMillis) {
        msg.target = this;
        msg.workSourceUid = ThreadLocalWorkSource.getUid();
        //异步消息
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        //消息入队
        return queue.enqueueMessage(msg, uptimeMillis);
    }</code></pre>
<h2 id="在-MessageQueue-中插入-Message"><a href="#在-MessageQueue-中插入-Message" class="headerlink" title="在 MessageQueue 中插入 Message"></a>在 MessageQueue 中插入 Message</h2><p>在 enqueueMessage 中主要做了几件事：</p>
<ol>
<li>将消息标记为已使用；</li>
<li>按照消息的发送时间 （uptimeMillis）将消息插入队列中的对应位置；</li>
<li>判断是否要 wakeup 一次 next 方法的等待；</li>
</ol>
<pre><code class="java"> boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }
            // 标记消息为已使用
            msg.markInUse();
            msg.when = when;
            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
                // 队列为空，或者需要立即发送或发送时间快于队首
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;//有新的消息，如果当前是 block 状态则需要 wakeup
            } else {
                // Inserted within the middle of the queue.  Usually we don&#39;t have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                // 除非是当前队首是同步屏障，并且这个消息是最早的异步消息，否则不需要 wakeup
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                // 循环找到发送时间大于当前消息的节点，将其插入找到的这个节点之前
                for (;;) {
                    prev = p;
                    p = p.next;
                    if (p == null || when &lt; p.when) {
                        break;
                    }
                    //如果后面的节点有异步消息，则这一次插入不需要wakeup
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
</code></pre>
<h2 id="MessageQueue-next-返回给-Looper-消息"><a href="#MessageQueue-next-返回给-Looper-消息" class="headerlink" title="MessageQueue.next 返回给 Looper 消息"></a>MessageQueue.next 返回给 Looper 消息</h2><p>next 方法有个大循环持续 wait &amp; get ，直到队列中取出合适的消息返回给 Looper 使用。</p>
<pre><code class="java">        int nextPollTimeoutMillis = 0;
        for (;;) {
            ...
            //该方法会持续 block，直到超时或者被 nativeWake 方法唤醒
            nativePollOnce(ptr, nextPollTimeoutMillis);
            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                //和异步消息有关，后续分析
                if (msg != null &amp;&amp; msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null &amp;&amp; !msg.isAsynchronous());
                }
                if (msg != null) {
                    if (now &lt; msg.when) {
                        //如果取出来的时间还没到，更新nextPollTimeoutMillis继续调用nativePollOnce等待
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        //将消息从队列中移除
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                        } else {
                            mMessages = msg.next;
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                        msg.markInUse();
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }
        ...
        }
        ...</code></pre>
<h1 id="消息同步屏障"><a href="#消息同步屏障" class="headerlink" title="消息同步屏障"></a>消息同步屏障</h1><h2 id="什么是同步屏障"><a href="#什么是同步屏障" class="headerlink" title="什么是同步屏障"></a>什么是同步屏障</h2><p>同步屏障是 MeesageQueue 中一种特殊的机制，源码注释如下，</p>
<blockquote>
<p>Message processing occurs as usual until the message queue encounters the<br>synchronization barrier that has been posted.  When the barrier is encountered,<br>later synchronous messages in the queue are stalled (prevented from being executed) until the barrier is released by calling {@link #removeSyncBarrier} and specifying the token that identifies the synchronization barrier.</p>
</blockquote>
<p>大概意思就是同步屏障是阻碍正常消息队列循环的一种手段，这个屏障会阻碍同步消息也就是平时我们发送的消息的循环，而异步消息还是正常发送，所以异步消息和同步屏障通常是搭配使用的。如下图所示：</p>
<p><img src="%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C.png" srcset="/img/loading.gif" alt="同步屏障.png"></p>
<p>同步屏障的意义简单来说，就像游戏服务器拥挤的时候，异步消息就是 VIP 玩家可以优先登录游戏，而普通玩家需要等到服务器缓解的时候才能登录。实际上在 Android 中，同步屏障的意义也是在于此，例如屏幕的绘制信号。</p>
<h2 id="同步屏障实现"><a href="#同步屏障实现" class="headerlink" title="同步屏障实现"></a>同步屏障实现</h2><h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>调用 MessageQueue 的 postSyncBarrier 放置一个同步屏障，when 参数指定屏障发生的时间。</p>
<pre><code class="java"> private int postSyncBarrier(long when) {
        // Enqueue a new sync barrier token.
        // We don&#39;t need to wake the queue because the purpose of a barrier is to stall it.
        synchronized (this) {
            final int token = mNextBarrierToken++;
            final Message msg = Message.obtain();
            msg.markInUse();
            msg.when = when;
            msg.arg1 = token;

            Message prev = null;
            Message p = mMessages;
            if (when != 0) {
                while (p != null &amp;&amp; p.when &lt;= when) {
                    prev = p;
                    p = p.next;
                }
            }
            if (prev != null) { // invariant: p == prev.next
                msg.next = p;
                prev.next = msg;
            } else {
                msg.next = p;
                mMessages = msg;
            }
            return token;
        }
    }</code></pre>
<p>从源码可以看出其实这个屏障就是一个特殊的 Message，它没有对应的 Handler，所以 target 为空，这条消息的插入逻辑和普通消息的插入是一样，但是这个插入不会唤醒 block 住的 poll 循环。</p>
<h3 id="处理屏障"><a href="#处理屏障" class="headerlink" title="处理屏障"></a>处理屏障</h3><p>同步屏障也是在 next 方法中实现的，上文 next 的源码中有一段：</p>
<pre><code class="java">                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                if (msg != null &amp;&amp; msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                  // 在这里实现同步屏障。如果当前队首消息是屏障消息（target==null），那么就循环寻找下一条异步消息取出队列。
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null &amp;&amp; !msg.isAsynchronous());
                }</code></pre>
<p>代码很短，很巧妙的就实现了这样的一个重要的功能。</p>
<h3 id="移除屏障"><a href="#移除屏障" class="headerlink" title="移除屏障"></a>移除屏障</h3><p>放置了同步屏障一定要在合适的时候进行移除，例如期望的异步消息得到了回调，不然这个屏障会一直存在，导致正常的同步消息无法正常回调！</p>
<p>通过调用 removeSyncBarrier 方法进行移除，传入 postSyncBarrier 返回的 token 作为参数，标识需要移除哪个屏障，然后将该屏障消息会从队列中移除。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>到此 Java 层的消息机制实现基本分析完毕了，代码虽然不多架构也比较简单，但不失为学习阅读 Android 源码的好例子。</p>
<p>在 Android2.3 之前是只有 Java 层上有这套代码，在之后 Native 层也实现了一套类似的机制，本文还没有对 native 部分代码进行深究，后续有时间会继续更新。</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Android/">Android</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">消息机制</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
                    
                      <a class="hover-with-bg" href="/tags/Handler/">Handler</a>
                    
                      <a class="hover-with-bg" href="/tags/Message/">Message</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/04/26/%E5%B0%8F%E8%AE%B0HashMap%E7%9B%B8%E5%85%B3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">小记HashMap相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/04/22/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BACUDA+cuDNN+tf+Python%E7%8E%AF%E5%A2%83/">
                        <span class="hidden-mobile">Ubuntu下搭建CUDA+cuDNN+tf+Python环境</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
      <!-- cnzz Analytics Icon -->
      <span id="cnzz_stat_icon_1278771147" style="display: none"></span>
    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->


  

  

  
    <!-- Tencent Analytics -->
    <script defer>
      var _mtac = {};
      (function () {
        var mta = document.createElement("script");
        mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500716418");
        
        mta.setAttribute("cid", "500716419");
        
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
      })();
    </script>
  

  

  

  
    <!-- cnzz Analytics -->
    <script defer src="//s4.cnzz.com/z_stat.php?id=1278771147&show=pic"
            type="text/javascript"></script>
  



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').each(function () {
        const pre = $(this);
        if (pre.find('code.mermaid').length > 0) {
          return;
        }
        pre.addClass('prettyprint  linenums');
      });
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "小记Android消息处理机制和同步屏障&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 35,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  












</body>
</html>
