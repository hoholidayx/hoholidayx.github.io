

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="hoholiday">
  <meta name="keywords" content="">
  <title>小记Android消息处理机制和同步屏障 - hohliday&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"hoholidayx.github.io","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":"500716418","cid":"500716419"},"woyaola":null,"cnzz":"1278771147","leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>hohliday's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="小记Android消息处理机制和同步屏障">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-04-25 18:56" pubdate>
        2020年4月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      35
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">小记Android消息处理机制和同步屏障</h1>
            
            <div class="markdown-body">
              <p>代码版本： <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30" target="_blank" rel="noopener">Android-10.0.0_r30</a></p>
<h1 id="消息处理架构"><a href="#消息处理架构" class="headerlink" title="消息处理架构"></a>消息处理架构</h1><p>在Java层上，Android实现消息处理机制主要有以下几个类：</p>
<ul>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Handler.java" target="_blank" rel="noopener">android/os/Handler.java</a></li>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Message.java" target="_blank" rel="noopener">android/os/Message.java</a></li>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/Looper.java" target="_blank" rel="noopener">android/os/Looper.java</a></li>
<li><a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="noopener">android/os/MessageQueue.java</a></li>
</ul>
<p>虽然它们之间的关系比较简单，但如果要深究其原理还是非常复杂的，特别是到native层部分。</p>
<p><img src="%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%9E%B6%E6%9E%84.png" alt="消息机制架构.png"></p>
<p>如图所示，Handler负责处理消息，类似一个句柄，其他线程可以向其发送 Message ， Message 进入消息队列 MessageQueue 中，一个运行在主线程的 Looper 不断从队列中取出消息，然后调用其 Handler 或者 Callback 处理逻辑。</p>
<h1 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h1><h2 id="构建Looper"><a href="#构建Looper" class="headerlink" title="构建Looper"></a>构建Looper</h2><p>Looper 的内部维护了一个 MessageQueue 对象，在线程中调用 Looper.prepare 来创建新的 Looper。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LooperThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>      Handler handler;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-comment">// 必须先调用</span><br>          Looper.prepare();<br>          <span class="hljs-comment">//用 Looper 来创建 Handler</span><br>          handler = <span class="hljs-keyword">new</span> Handler(Looper.myLooper());<br>          Looper.loop();<br>      &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>Looper#prepare 方法里，构建一个新的 Looper 对象，然后将其放入静态的<br> sThreadLocal 中。</p>
<blockquote>
<p>ThreadLocal: This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. </p>
</blockquote>
<p>如果重复调用 prepare 会抛出异常，所以<strong>每个线程只能有一个 Looper</strong>。</p>
<p>在主线程（UI Thread）中不需要创建 Looper，因为在应用 ActivityThread 创建出来的时候，在 <a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r30:frameworks/base/core/java/android/app/ActivityThread.java;l=7329;drc=0a9ee1af2cba8da1de3aace999d8547503c06f4c" target="_blank" rel="noopener">main</a> 方法中已经调用过 Looper#prepareMainLooper 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Only one Looper may be created per thread"</span>);<br>        &#125;<br>        sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>最后调用 Looper#loop 方法，创建一个 MessageQueue 并循环等待调用其 next 方法得到下一条要被处理的消息，将这个消息分发给对应的处理者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">final</span> Looper me = myLooper();<br>		...<br>        <span class="hljs-keyword">final</span> MessageQueue queue = me.mQueue;<br>        ...<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            Message msg = queue.next(); <span class="hljs-comment">// might block</span><br>            ...<br>            <span class="hljs-comment">// 分发事件给 target 处理，也就是消息对应的 Handler</span><br>            msg.target.dispatchMessage(msg); <br>            ...<br>            <span class="hljs-comment">// 回收 Message</span><br>            msg.recycleUnchecked();<br>        &#125;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里Looper 的主要工作就结束了。</p>
<h2 id="构建Handler"><a href="#构建Handler" class="headerlink" title="构建Handler"></a>构建Handler</h2><p>Handler 的构建必须依赖 Looper 作为参数，否则就是无效 Handler，即使在主线程创建，Google 官方还是推荐使用以 Looper 作为参数的构建方式来创建 Handler，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Handler h = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());<br></code></pre></td></tr></table></figure>
<p>在新版的代码中可以看到，Handler 的无参构建方法已经标记为 Deprecated 了，目的是避免错误隐患和保证代码可读性。</p>
<p>Handler 还有几个被 hide 的构造方法，和异步消息有关，后续继续分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br>* <span class="hljs-doctag">@hide</span><br>*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, async);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Handler-处理消息"><a href="#Handler-处理消息" class="headerlink" title="Handler 处理消息"></a>Handler 处理消息</h2><p>Handler 的 dispatchMessage 方法负责接收 Looper 分发的消息，可以看到消息处理的优先级：</p>
<p>Message 内的 callback &gt; Handler 的 callback &gt; handleMessage 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(@NonNull Message msg)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;<br>           handleCallback(msg); <span class="hljs-comment">// 1</span><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;<br>               <span class="hljs-comment">// 2</span><br>               <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>           &#125;<br>           handleMessage(msg); <span class="hljs-comment">// 3</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h1 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h1><h2 id="构造-Message"><a href="#构造-Message" class="headerlink" title="构造 Message"></a>构造 Message</h2><p>构造一个 Message 对象可以直接 new 一个出来，但是一般都使用 Message.obtain() 从对象池中获取，否则如果消息频率太高会导致短时间内存占用上升，虚拟机频繁 <a href="https://hoholidayx.github.io/2019/10/22/%E5%B0%8F%E8%AE%B0Java%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B3%95">GC</a>  影响性能。</p>
<p>Message 其实是链表结构，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> what;<br>    ...<br>    <span class="hljs-comment">// sometimes we store linked lists of these things</span><br>    <span class="hljs-comment">/*package*/</span> Message next;<br>    ...<br>    <span class="hljs-comment">// 对象池起始当前节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message sPool;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用一个静态 sPool 变量表示当前对象池链表的头节点，通过 obtain 方法获取 Message 的时候把头结点从链表移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">obtain</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-keyword">null</span>) &#123;<br>            Message m = sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-keyword">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Message();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Message 使用完后调用 recycle 方法进入 recycleUncheckd ，将当前Message插入回链表头部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<br>    next = sPool;<br>    sPool = <span class="hljs-keyword">this</span>;<br>    sPoolSize++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以实际上这个对象池是一个用链表实现的栈。</p>
<h2 id="通过-Handler-发送-Message"><a href="#通过-Handler-发送-Message" class="headerlink" title="通过 Handler 发送 Message"></a>通过 Handler 发送 Message</h2><p>调用 Handler 的 sendMessage 方法，最后到 sendMessageAtTime 中，向 MessageQueue 入队消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(@NonNull MessageQueue queue, @NonNull Message msg,<br>           <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>       msg.target = <span class="hljs-keyword">this</span>;<br>       msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>       <span class="hljs-comment">//异步消息</span><br>       <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>           msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>       &#125;<br>       <span class="hljs-comment">//消息入队</span><br>       <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="在-MessageQueue-中插入-Message"><a href="#在-MessageQueue-中插入-Message" class="headerlink" title="在 MessageQueue 中插入 Message"></a>在 MessageQueue 中插入 Message</h2><p>在 enqueueMessage 中主要做了几件事：</p>
<ol>
<li>将消息标记为已使用；</li>
<li>按照消息的发送时间 （uptimeMillis）将消息插入队列中的对应位置；</li>
<li>判断是否要 wakeup 一次 next 方法的等待；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Message must have a target."</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">" This message is already in use."</span>);<br>       &#125;<br><br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>           <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>               IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(<br>                       msg.target + <span class="hljs-string">" sending message to a Handler on a dead thread"</span>);<br>               Log.w(TAG, e.getMessage(), e);<br>               msg.recycle();<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>           &#125;<br>           <span class="hljs-comment">// 标记消息为已使用</span><br>           msg.markInUse();<br>           msg.when = when;<br>           Message p = mMessages;<br>           <span class="hljs-keyword">boolean</span> needWake;<br>           <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>           	<span class="hljs-comment">// 队列为空，或者需要立即发送或发送时间快于队首</span><br>               <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>               msg.next = p;<br>               mMessages = msg;<br>               needWake = mBlocked;<span class="hljs-comment">//有新的消息，如果当前是 block 状态则需要 wakeup</span><br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span><br>               <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>               <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>               <span class="hljs-comment">// 除非是当前队首是同步屏障，并且这个消息是最早的异步消息，否则不需要 wakeup</span><br>               needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>               Message prev;<br>               <span class="hljs-comment">// 循环找到发送时间大于当前消息的节点，将其插入找到的这个节点之前</span><br>               <span class="hljs-keyword">for</span> (;;) &#123;<br>                   prev = p;<br>                   p = p.next;<br>                   <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                       <span class="hljs-keyword">break</span>;<br>                   &#125;<br>                   <span class="hljs-comment">//如果后面的节点有异步消息，则这一次插入不需要wakeup</span><br>                   <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                       needWake = <span class="hljs-keyword">false</span>;<br>                   &#125;<br>               &#125;<br>               msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>               prev.next = msg;<br>           &#125;<br><br>           <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>           <span class="hljs-keyword">if</span> (needWake) &#123;<br>               nativeWake(mPtr);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h2 id="MessageQueue-next-返回给-Looper-消息"><a href="#MessageQueue-next-返回给-Looper-消息" class="headerlink" title="MessageQueue.next 返回给 Looper 消息"></a>MessageQueue.next 返回给 Looper 消息</h2><p>next 方法有个大循环持续 wait &amp; get ，直到队列中取出合适的消息返回给 Looper 使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>    ...<br>    <span class="hljs-comment">//该方法会持续 block，直到超时或者被 nativeWake 方法唤醒</span><br>    nativePollOnce(ptr, nextPollTimeoutMillis);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>        Message prevMsg = <span class="hljs-keyword">null</span>;<br>        Message msg = mMessages;<br>        <span class="hljs-comment">//和异步消息有关，后续分析</span><br>        <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                prevMsg = msg;<br>                msg = msg.next;<br>            &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>            	<span class="hljs-comment">//如果取出来的时间还没到，更新nextPollTimeoutMillis继续调用nativePollOnce等待</span><br>                <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Got a message.</span><br>                mBlocked = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">//将消息从队列中移除</span><br>                <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>                    prevMsg.next = msg.next;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mMessages = msg.next;<br>                &#125;<br>                msg.next = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">"Returning message: "</span> + msg);<br>                msg.markInUse();<br>                <span class="hljs-keyword">return</span> msg;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// No more messages.</span><br>            nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>        &#125;<br>...<br>&#125;<br>...<br></code></pre></td></tr></table></figure>

<h1 id="消息同步屏障"><a href="#消息同步屏障" class="headerlink" title="消息同步屏障"></a>消息同步屏障</h1><h2 id="什么是同步屏障"><a href="#什么是同步屏障" class="headerlink" title="什么是同步屏障"></a>什么是同步屏障</h2><p>同步屏障是 MeesageQueue 中一种特殊的机制，源码注释如下，</p>
<blockquote>
<p>Message processing occurs as usual until the message queue encounters the<br>synchronization barrier that has been posted.  When the barrier is encountered,<br>later synchronous messages in the queue are stalled (prevented from being executed) until the barrier is released by calling {@link #removeSyncBarrier} and specifying the token that identifies the synchronization barrier.</p>
</blockquote>
<p>大概意思就是同步屏障是阻碍正常消息队列循环的一种手段，这个屏障会阻碍同步消息也就是平时我们发送的消息的循环，而异步消息还是正常发送，所以异步消息和同步屏障通常是搭配使用的。如下图所示：</p>
<p><img src="%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C.png" alt="同步屏障.png"></p>
<p>同步屏障的意义简单来说，就像游戏服务器拥挤的时候，异步消息就是 VIP 玩家可以优先登录游戏，而普通玩家需要等到服务器缓解的时候才能登录。实际上在 Android 中，同步屏障的意义也是在于此，例如屏幕的绘制信号。</p>
<h2 id="同步屏障实现"><a href="#同步屏障实现" class="headerlink" title="同步屏障实现"></a>同步屏障实现</h2><h3 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h3><p>调用 MessageQueue 的 postSyncBarrier 放置一个同步屏障，when 参数指定屏障发生的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>       <span class="hljs-comment">// Enqueue a new sync barrier token.</span><br>       <span class="hljs-comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span><br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>           <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> token = mNextBarrierToken++;<br>           <span class="hljs-keyword">final</span> Message msg = Message.obtain();<br>           msg.markInUse();<br>           msg.when = when;<br>           msg.arg1 = token;<br><br>           Message prev = <span class="hljs-keyword">null</span>;<br>           Message p = mMessages;<br>           <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                   prev = p;<br>                   p = p.next;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span><br>               msg.next = p;<br>               prev.next = msg;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               msg.next = p;<br>               mMessages = msg;<br>           &#125;<br>           <span class="hljs-keyword">return</span> token;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>从源码可以看出其实这个屏障就是一个特殊的 Message，它没有对应的 Handler，所以 target 为空，这条消息的插入逻辑和普通消息的插入是一样，但是这个插入不会唤醒 block 住的 poll 循环。</p>
<h3 id="处理屏障"><a href="#处理屏障" class="headerlink" title="处理屏障"></a>处理屏障</h3><p>同步屏障也是在 next 方法中实现的，上文 next 的源码中有一段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>Message prevMsg = <span class="hljs-keyword">null</span>;<br>Message msg = mMessages;<br><span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>  <span class="hljs-comment">// 在这里实现同步屏障。如果当前队首消息是屏障消息（target==null），那么就循环寻找下一条异步消息取出队列。</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        prevMsg = msg;<br>        msg = msg.next;<br>    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码很短，很巧妙的就实现了这样的一个重要的功能。</p>
<h3 id="移除屏障"><a href="#移除屏障" class="headerlink" title="移除屏障"></a>移除屏障</h3><p>放置了同步屏障一定要在合适的时候进行移除，例如期望的异步消息得到了回调，不然这个屏障会一直存在，导致正常的同步消息无法正常回调！</p>
<p>通过调用 removeSyncBarrier 方法进行移除，传入 postSyncBarrier 返回的 token 作为参数，标识需要移除哪个屏障，然后将该屏障消息会从队列中移除。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>到此 Java 层的消息机制实现基本分析完毕了，代码虽然不多架构也比较简单，但不失为学习阅读 Android 源码的好例子。</p>
<p>在 Android2.3 之前是只有 Java 层上有这套代码，在之后 Native 层也实现了一套类似的机制，本文还没有对 native 部分代码进行深究，后续有时间会继续更新。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Android/">Android</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android/">Android</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">消息机制</a>
                    
                      <a class="hover-with-bg" href="/tags/Handler/">Handler</a>
                    
                      <a class="hover-with-bg" href="/tags/Message/">Message</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/04/26/%E5%B0%8F%E8%AE%B0HashMap%E7%9B%B8%E5%85%B3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">小记HashMap相关</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/04/22/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BACUDA+cuDNN+tf+Python%E7%8E%AF%E5%A2%83/">
                        <span class="hidden-mobile">Ubuntu下搭建CUDA+cuDNN+tf+Python环境</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
    <!-- cnzz Analytics Icon -->
    <span id="cnzz_stat_icon_1278771147" style="display: none"></span>
  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  

  

  

  
    <!-- Tencent Analytics -->
    <script defer>
      var _mtac = {};
      (function () {
        var mta = document.createElement("script");
        mta.src = "//pingjs.qq.com/h5/stats.js?v2.0.4";
        mta.setAttribute("name", "MTAH5");
        mta.setAttribute("sid", "500716418");
        
        mta.setAttribute("cid", "500716419");
        
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(mta, s);
      })();
    </script>
  

  

  
    <!-- cnzz Analytics -->
    <script defer src="//s4.cnzz.com/z_stat.php?id=1278771147&show=pic"
            type="text/javascript"></script>
  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
